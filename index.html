<!DOCTYPE html>
<html lang="ja">
<head>
  
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Stroke Studio">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a2e">
<title>Stroke Animation Studio</title>
<script>
// PWA: アイコン＋マニフェスト（GitHub Pages対応）
(function(){
  const icon192='data:image/png;base64,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';
  const icon512='data:image/png;base64,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';

  // apple-touch-icon
  const al=document.createElement('link');al.rel='apple-touch-icon';al.href=icon192;document.head.appendChild(al);

  // マニフェスト（data URLでGitHub Pages対応）
  const manifest={
    name:'Stroke Animation Studio',short_name:'Stroke Studio',
    start_url:location.href.replace(/[?#].*/,''),
    id:'stroke-animation-studio',
    display:'standalone',orientation:'landscape',
    background_color:'#1a1a2e',theme_color:'#1a1a2e',
    icons:[
      {src:icon192,sizes:'192x192',type:'image/png'},
      {src:icon512,sizes:'512x512',type:'image/png',purpose:'any maskable'}
    ]
  };
  const manifestB64=btoa(unescape(encodeURIComponent(JSON.stringify(manifest))));
  const ml=document.createElement('link');ml.rel='manifest';ml.href='data:application/manifest+json;base64,'+manifestB64;document.head.appendChild(ml);

  // Service Worker
  if('serviceWorker' in navigator){
    const swPath=new URL('sw.js',location.href).href;
    navigator.serviceWorker.register(swPath).catch(function(){});
  }

  // beforeinstallprompt対応
  let deferredPrompt=null;
  window.addEventListener('beforeinstallprompt',function(e){
    e.preventDefault();
    deferredPrompt=e;
  });
  window._installPWA=function(){
    if(deferredPrompt){deferredPrompt.prompt();deferredPrompt=null;}
    else{alert('ブラウザのメニューから「ホーム画面に追加」または「アプリをインストール」を選択してください');}
  };
})();
</script>
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
:root {
  --bg-primary:#1a1a2e;--bg-secondary:#16213e;--bg-tertiary:#0f3460;
  --bg-panel:#1c1c3a;--bg-input:#252547;
  --accent:#e94560;--accent-hover:#ff6b81;
  --text-primary:#eaeaea;--text-secondary:#a0a0c0;--text-muted:#6a6a8a;
  --border:#2a2a4a;--border-light:#3a3a5a;
  --success:#4ecdc4;--warning:#f9a825;
  --layer-color-1:#e94560;--layer-color-2:#4ecdc4;
  --layer-color-3:#f9a825;--layer-color-4:#a855f7;
  --draft-color-1:#555580;--draft-color-2:#555580;--draft-color-3:#555580;--draft-color-4:#555580;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Segoe UI','Meiryo',sans-serif;background:var(--bg-primary);color:var(--text-primary);overflow:hidden;height:100vh;user-select:none;}
::-webkit-scrollbar{width:6px;height:6px;}
::-webkit-scrollbar-track{background:var(--bg-primary);}
::-webkit-scrollbar-thumb{background:var(--border-light);border-radius:3px;}

#header{display:flex;align-items:center;height:36px;background:var(--bg-secondary);border-bottom:1px solid var(--border);padding:0 10px;gap:5px;}
#header .app-title{font-size:13px;font-weight:700;color:var(--accent);margin-right:12px;}
.header-btn{background:transparent;border:1px solid var(--border);color:var(--text-secondary);padding:3px 10px;font-size:11px;border-radius:3px;cursor:pointer;white-space:nowrap;}
.header-btn:hover{background:var(--bg-tertiary);color:var(--text-primary);}
.header-sep{width:1px;height:20px;background:var(--border);margin:0 3px;}
#project-name-input{background:var(--bg-input);border:1px solid var(--border);color:var(--text-primary);padding:3px 8px;font-size:11px;border-radius:3px;width:140px;}
#project-name-input::placeholder{color:var(--text-muted);}

#main-layout{display:flex;height:calc(100vh - 36px);}

#toolbar{width:44px;background:var(--bg-secondary);border-right:1px solid var(--border);display:flex;flex-direction:column;align-items:center;padding:8px 0;gap:2px;}
.tool-btn{width:34px;height:34px;background:transparent;border:none;border-radius:4px;color:var(--text-secondary);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:16px;position:relative;}
.tool-btn:hover{background:var(--bg-input);color:var(--text-primary);}
.tool-btn.active{background:var(--accent);color:#fff;}
.tool-btn svg{width:18px;height:18px;}
.tool-btn .shortcut{position:absolute;bottom:1px;right:2px;font-size:7px;color:var(--text-muted);pointer-events:none;}
.tool-btn.active .shortcut{color:rgba(255,255,255,0.6);}
.tool-sep{width:28px;height:1px;background:var(--border);margin:4px 0;}
#pen-settings{display:flex;flex-direction:column;align-items:center;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);}
#stroke-point-settings{display:flex;flex-direction:column;align-items:center;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);}
#stroke-point-settings label{font-size:9px;color:var(--text-muted);}
#stroke-point-val{font-size:10px;color:var(--text-secondary);}
#stroke-point-slider{width:30px;writing-mode:vertical-lr;direction:rtl;-webkit-appearance:none;appearance:none;background:transparent;cursor:pointer;height:80px;}
#stroke-point-slider::-webkit-slider-runnable-track{width:4px;background:var(--border-light);border-radius:2px;}
#stroke-point-slider::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;background:var(--accent);border-radius:50%;margin-left:-4px;}
#pen-settings label{font-size:9px;color:var(--text-muted);}
#pen-size-val{font-size:10px;color:var(--text-secondary);}
#pen-smooth-val{font-size:10px;color:var(--text-secondary);}
#pen-size{width:30px;writing-mode:vertical-lr;direction:rtl;-webkit-appearance:none;appearance:none;background:transparent;cursor:pointer;height:80px;}
#pen-smooth{width:30px;writing-mode:vertical-lr;direction:rtl;-webkit-appearance:none;appearance:none;background:transparent;cursor:pointer;height:60px;}
#pen-size::-webkit-slider-runnable-track{width:4px;background:var(--border-light);border-radius:2px;}
#pen-smooth::-webkit-slider-runnable-track{width:4px;background:var(--border-light);border-radius:2px;}
#pen-size::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;background:var(--accent);border-radius:50%;margin-left:-4px;}
#pen-smooth::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;background:var(--accent);border-radius:50%;margin-left:-4px;}
#pen-color{width:28px;height:28px;border:2px solid var(--border-light);border-radius:4px;cursor:pointer;background:#000;padding:0;}
#pen-color::-webkit-color-swatch-wrapper{padding:0;}
#pen-color::-webkit-color-swatch{border:none;border-radius:2px;}

#canvas-area{flex:1;position:relative;overflow:hidden;background:#111128;cursor:crosshair;touch-action:none;}
#canvas-container{position:absolute;transform-origin:0 0;}
.canvas-layer{position:absolute;top:0;left:0;}
#canvas-bg{position:absolute;top:0;left:0;background:#fff;box-shadow:0 4px 24px rgba(0,0,0,0.5);}
#onion-canvas{position:absolute;top:0;left:0;pointer-events:none;opacity:1;}
#stroke-guide-canvas{position:absolute;top:0;left:0;pointer-events:none;z-index:5;}
#cursor-preview{position:fixed;pointer-events:none;border:1.5px solid rgba(233,69,96,0.7);border-radius:50%;z-index:100;display:none;}
#rotation-indicator{position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:var(--text-primary);padding:4px 12px;border-radius:4px;font-size:12px;display:none;z-index:50;}
#zoom-indicator{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:var(--text-primary);padding:4px 12px;border-radius:4px;font-size:11px;z-index:50;}
#stroke-order-overlay{position:absolute;top:0;left:0;pointer-events:none;z-index:10;}
#point-edit-overlay{position:absolute;top:0;left:0;pointer-events:none;z-index:6;}
#view-tools{display:flex;align-items:center;gap:3px;}
.view-tool-btn{font-size:16px !important;}
.view-tool-btn.active{background:var(--accent) !important;color:#fff !important;}
#frame-guide-overlay{position:absolute;pointer-events:none;z-index:8;border:2px solid rgba(0,180,255,0.7);box-sizing:border-box;display:none;box-shadow:0 0 0 9999px rgba(0,0,0,0.25);}

#right-panel{width:220px;background:var(--bg-panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;}
.panel-section{border-bottom:1px solid var(--border);}
.panel-header{display:flex;align-items:center;justify-content:space-between;padding:6px 10px;background:var(--bg-secondary);font-size:12px;font-weight:600;color:var(--text-secondary);}
.panel-body{padding:8px;}
.layer-item{display:flex;align-items:center;gap:6px;padding:5px 6px;border-radius:4px;cursor:pointer;font-size:11px;margin-bottom:2px;}
.layer-item:hover{background:var(--bg-input);}
.layer-item.active{background:var(--bg-tertiary);outline:1px solid var(--accent);}
.layer-color-dot{width:10px;height:10px;border-radius:50%;flex-shrink:0;}
.layer-name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
.layer-vis-btn{width:20px;height:20px;background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:12px;display:flex;align-items:center;justify-content:center;border-radius:3px;}
.layer-vis-btn:hover{background:var(--bg-input);color:var(--text-primary);}
.layer-vis-btn.hidden{opacity:0.3;}
.layer-actions{display:flex;gap:4px;padding:4px 6px;}
.layer-action-btn{flex:1;background:var(--bg-input);border:1px solid var(--border);color:var(--text-secondary);padding:3px;font-size:10px;border-radius:3px;cursor:pointer;}
.layer-action-btn:hover{background:var(--bg-tertiary);color:var(--text-primary);}
.onion-row{display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-secondary);margin-bottom:4px;}
.onion-row label{flex:1;}
.onion-row input[type="checkbox"]{accent-color:var(--accent);}
.onion-row input[type="number"]{width:50px;background:var(--bg-input);border:1px solid var(--border);color:var(--text-primary);padding:2px 4px;font-size:10px;border-radius:3px;text-align:center;}
.layer-onion-btn{padding:2px 4px;font-size:9px;border-radius:3px;border:none;background:transparent;color:var(--text-muted);cursor:pointer;opacity:0.4;transition:all 0.15s;}
.layer-onion-btn.active{opacity:1;color:#f7a440;}
.layer-onion-btn:hover{opacity:0.8;}

.cut-item{display:flex;align-items:center;gap:6px;padding:4px 6px;border-radius:4px;cursor:pointer;font-size:11px;margin-bottom:2px;}
.cut-item:hover{background:var(--bg-input);}
.cut-item.active{background:var(--bg-tertiary);outline:1px solid var(--accent);}
.cut-item .cut-label{flex:1;font-weight:600;}
.cut-item .cut-frames{font-size:9px;color:var(--text-muted);}
.cut-actions{display:flex;gap:4px;padding:4px 6px;}

#timeline-panel{position:fixed;bottom:0;left:44px;right:220px;background:var(--bg-panel);border-top:1px solid var(--border);display:flex;flex-direction:column;z-index:20;}
#timeline-controls{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg-secondary);border-bottom:1px solid var(--border);min-height:32px;flex-shrink:0;flex-wrap:wrap;}
.tl-btn{width:26px;height:26px;background:var(--bg-input);border:1px solid var(--border);color:var(--text-secondary);border-radius:3px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px;}
.tl-btn:hover{background:var(--bg-tertiary);color:var(--text-primary);}
.tl-btn.active{background:var(--accent);color:#fff;border-color:var(--accent);}
.tl-info{font-size:11px;color:var(--text-secondary);margin-left:6px;}
.tl-info span{color:var(--text-primary);font-weight:600;}
#fps-input{width:36px;background:var(--bg-input);border:1px solid var(--border);color:var(--text-primary);padding:2px 4px;font-size:11px;border-radius:3px;text-align:center;}
#timeline-body{flex:1;display:flex;overflow:hidden;}
#tl-layer-labels{width:100px;background:var(--bg-secondary);border-right:1px solid var(--border);overflow:hidden;flex-shrink:0;}
#tl-layer-labels-inner{padding-top:18px;}
.tl-layer-label{height:24px;display:flex;align-items:center;padding:0 8px;font-size:10px;color:var(--text-secondary);border-bottom:1px solid var(--border);cursor:pointer;}
.tl-layer-label.active{color:var(--text-primary);background:var(--bg-tertiary);}
.tl-layer-label .dot{width:6px;height:6px;border-radius:50%;margin-right:6px;flex-shrink:0;}
#tl-frames-area{flex:1;overflow-x:auto;overflow-y:auto;position:relative;}
#tl-header{position:sticky;top:0;height:18px;background:var(--bg-secondary);border-bottom:1px solid var(--border);z-index:2;display:flex;}
.tl-frame-num{width:28px;min-width:28px;height:18px;display:flex;align-items:center;justify-content:center;font-size:8px;color:var(--text-muted);border-right:1px solid var(--border);cursor:pointer;}
/* 右側スクロール領域を「横に無制限に伸ばせる」ようにする */
#tl-right-scrollable {
  flex: 1 1 auto;                  /* flex-growを効かせる */
  overflow-y: auto;                /* 縦スクロールは残す */
  overflow-x: visible !important;  /* ← 横ははみ出し許可（重要！） */
  position: relative;
  min-width: 0;                    /* flexの子が縮まないように */
}

/* フレーム領域自体も横に伸びることを保証 */
#tl-frames-area {
  display: block;                  /* flex から block に変更（横伸び重視） */
  width: auto !important;
  min-width: fit-content !important;
  max-width: none !important;
  overflow: visible !important;
  white-space: nowrap;             /* セルが折り返さない */
}

/* ヘッダーと行も横に無制限 */
#tl-header,
.tl-row {
  width: auto !important;
  min-width: fit-content !important;
  max-width: none !important;
  display: flex;
  flex-wrap: nowrap;               /* 絶対に折り返さない */
}

/* セル自体は固定幅のまま */
.tl-cell,
.tl-frame-num {
  width: 28px !important;
  min-width: 28px !important;
  max-width: 28px !important;
  flex: 0 0 28px;
}
.tl-frame-num.current{background:var(--accent);color:#fff;}
#tl-rows{position:relative;}
.tl-row{height:24px;display:flex;border-bottom:1px solid var(--border);}
.tl-cell{width:28px;min-width:28px;height:24px;border-right:1px solid rgba(42,42,74,0.5);display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;}
.tl-cell:hover{background:rgba(233,69,96,0.1);}
.tl-cell.has-data{background:rgba(78,205,196,0.15);}
.tl-cell.has-data::after{content:'';width:8px;height:8px;background:var(--success);border-radius:50%;}
.tl-cell.current-frame{background:rgba(233,69,96,0.15);}
.tl-cell.hold-frame{background:rgba(249,168,37,0.08);}
.tl-cell.hold-frame::after{content:'';width:14px;height:3px;background:var(--warning);border-radius:2px;opacity:0.5;}
.tl-cell.hold-start{background:rgba(249,168,37,0.2);}
.tl-cell.hold-start::after{content:'';width:8px;height:8px;background:var(--warning);border-radius:50%;}
.tl-cell.tl-selected{outline:2px solid var(--accent);outline-offset:-2px;z-index:1;}
.tl-cell.tl-drag-ghost{background:rgba(233,69,96,0.25);outline:2px dashed var(--accent);outline-offset:-2px;z-index:1;}
#tl-scroll-container {
  overflow-x: auto;
  overflow-y: auto;
  flex: 1;
  display: flex;
}
#tl-layer-labels {
  flex-shrink: 0;
  width: 100px;
}
#tl-frames-area {
  display: block;                  /* flex から block に変更（横伸び重視） */
  width: auto !important;
  min-width: fit-content !important;
  max-width: none !important;
  overflow: visible !important;
  white-space: nowrap;             /* セルが折り返さない */
}
#tl-scroll-container::-webkit-scrollbar {
  width: 12px;
  height: 12px;  /* 横スクロールバーの高さ */
}

#tl-scroll-container::-webkit-scrollbar-track {
  background: var(--bg-primary);
}

#tl-scroll-container::-webkit-scrollbar-thumb {
  background: var(--border-light);
  border-radius: 6px;
}

#tl-scroll-container::-webkit-scrollbar-thumb:hover {
  background: var(--accent);
}
/* 音声波形をタイムライン全体に合わせて自由に伸ばす */
#tl-audio-row {
  height: 24px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  position: sticky;
  bottom: 0;
  z-index: 1;
  width: auto !important;           /* 自動幅強制 */
  min-width: 100% !important;
  max-width: none !important;       /* 上限解除 */
  overflow: visible !important;     /* はみ出し許可 */
}

#tl-audio-wave {
  height: 100%;
  position: relative;
  overflow: visible !important;     /* hidden → visible に変更 */
  width: auto !important;
  min-width: fit-content !important;
  max-width: none !important;
}

#audio-waveform-canvas {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: auto !important;
  min-width: fit-content !important;
  max-width: none !important;
  pointer-events: none;
}
#audio-playhead {
  position: absolute;
  top: 0;
  height: 24px;
  width: 2px;
  background: #e94560;
  pointer-events: none;
}

/* コンテキストメニュー */
#ctx-menu{display:none;position:fixed;background:var(--bg-secondary);border:1px solid var(--border-light);border-radius:6px;padding:4px 0;z-index:300;box-shadow:0 4px 16px rgba(0,0,0,0.6);min-width:160px;}
.ctx-item{padding:6px 14px;font-size:11px;color:var(--text-secondary);cursor:pointer;display:flex;align-items:center;gap:8px;}
.ctx-item:hover{background:var(--bg-tertiary);color:var(--text-primary);}
.ctx-item.disabled{opacity:0.35;pointer-events:none;}
.ctx-sep{height:1px;background:var(--border);margin:3px 8px;}
.ctx-item .ctx-shortcut{margin-left:auto;font-size:9px;color:var(--text-muted);}

.modal-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:500;align-items:center;justify-content:center;}
.modal-overlay.show{display:flex;}
.modal-box{background:var(--bg-panel);border:1px solid var(--border-light);border-radius:8px;padding:20px;min-width:300px;box-shadow:0 8px 32px rgba(0,0,0,0.5);}
.modal-box h3{font-size:14px;margin-bottom:12px;color:var(--accent);}
.modal-row{display:flex;align-items:center;gap:8px;margin-bottom:8px;}
.modal-row label{font-size:12px;color:var(--text-secondary);width:70px;}
.modal-row input,.modal-row select{flex:1;background:var(--bg-input);border:1px solid var(--border);color:var(--text-primary);padding:5px 8px;font-size:12px;border-radius:4px;}
.modal-buttons{display:flex;gap:8px;margin-top:14px;justify-content:flex-end;}
.modal-btn{padding:5px 16px;font-size:12px;border-radius:4px;border:1px solid var(--border);cursor:pointer;}
.modal-btn.primary{background:var(--accent);color:#fff;border-color:var(--accent);}
.modal-btn.secondary{background:var(--bg-input);color:var(--text-secondary);}
.modal-btn:hover{opacity:0.85;}
#inbetween-preview{width:100%;height:150px;background:#fff;border:1px solid var(--border);border-radius:4px;margin:8px 0;}
#notification{position:fixed;top:50px;right:20px;background:var(--bg-secondary);border:1px solid var(--success);color:var(--text-primary);padding:8px 16px;border-radius:6px;font-size:12px;z-index:999;display:none;box-shadow:0 4px 16px rgba(0,0,0,0.4);}
#export-progress{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--bg-panel);border:1px solid var(--border-light);border-radius:8px;padding:24px;z-index:600;display:none;text-align:center;min-width:260px;box-shadow:0 8px 32px rgba(0,0,0,0.6);}
#export-progress h4{font-size:13px;color:var(--accent);margin-bottom:10px;}
#export-progress-bar{width:100%;height:6px;background:var(--bg-input);border-radius:3px;overflow:hidden;margin-bottom:8px;}
#export-progress-fill{height:100%;background:var(--accent);width:0%;transition:width 0.2s;}
#export-progress-text{font-size:11px;color:var(--text-secondary);}

/* モバイル/タブレット対応 */
@media(max-width:900px){
  #app{flex-direction:column;}
  #main-area{flex-direction:column;}
  #toolbar{flex-direction:row;width:100%;height:40px;overflow-x:auto;overflow-y:hidden;}
  #right-panel{width:100%;max-height:200px;overflow-y:auto;flex-direction:row;flex-wrap:wrap;}
  #right-panel .panel-section{min-width:180px;flex:1;}
  #timeline-panel{left:0;right:0;}
  #canvas-area{min-height:300px;}
  #header{flex-wrap:wrap;height:auto;padding:4px 8px;}
  .header-btn{padding:4px 8px;font-size:10px;}
  .tool-btn{width:34px;height:34px;min-width:34px;font-size:14px;}
}
@media(max-width:600px){
  #right-panel{max-height:160px;}
  .tl-cell{width:22px;min-width:22px;height:20px;}
  .tl-frame-num{width:22px;min-width:22px;}
}
/* タッチデバイスでホバー無効 */
@media(hover:none){
  .tl-cell:hover{background:none;}
  .tool-btn:hover{background:none;}
  .header-btn:hover{background:none;}
}

#floatingPopup{
  position: fixed;
  top: 80px;
  right: 80px;
  width: 320px;
  height: 320px;
  z-index: 2147483647;
}


#popupHeader{
  height: 28px;
  background: #333;
  cursor: move;
  color: #ccc;
  font-size: 12px;
  display: flex;
  align-items: center;
  padding: 0 8px;
}

#popupBody{
  width: 100%;
  height: calc(100% - 28px);
}

#popupBody iframe{
  width: 100%;
  height: 100%;
  border: none;
}

#resizeHandle{
  position: absolute;
  right: 0;
  bottom: 0;
  width: 14px;
  height: 14px;
  cursor: se-resize;
  background:
    linear-gradient(135deg,
      transparent 0%,
      transparent 40%,
      #666 40%,
      #666 60%,
      transparent 60%);
}

/* カラーパレットボタン（シンプル・安定版） */
#color-palette {
  display: flex;
  gap: 10px;
  justify-content: center;
  padding: 8px 0;
}


.color-swatch {
  width: 30px;
  height: 30px;
  border-radius: 8px;           /* 角丸四角 */
  border: 2px solid #444;       /* 暗めの枠線 */
  cursor: pointer;
  transition: none;             /* アニメーション完全オフ → チカチカ防止 */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.6); /* 少し立体感 */
}

.color-swatch:hover {
  box-shadow: 0 0 0 3px rgba(233,69,96,0.5); /* ホバー時は軽く光るだけ */
  transform: scale(1.08);
}

.color-swatch.active {
  border-color: #e94560;
  box-shadow: 0 0 0 4px rgba(233,69,96,0.4);
}

/* 各ボタンの背景色（HTMLのdata-colorで自動設定） */
.color-swatch[data-color="#000000"] { background: #000000; }
.color-swatch[data-color="#ffffff"] { background: #ffffff; }
.color-swatch[data-color="#e94560"] { background: #e94560; }
.color-swatch[data-color="#0000ff"] { background: #0000ff; }
.color-swatch[data-color="#ffff00"] { background: #ffff00; }
.color-swatch[data-color="#87FF42"] { background: #87FF42; }

/* 音声トラック行 */
#tl-audio-row {
  height: 60px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  position: relative;
  overflow: hidden;
}

#tl-audio-label {
  width: 100px;
  height: 60px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  color: var(--text-secondary);
  flex-shrink: 0;
}

#tl-audio-wave {
  flex: 1;
  height: 60px;
  position: relative;
  overflow-x: auto;
  overflow-y: hidden;
}

#audio-waveform-canvas {
  position: absolute;
  top: 0;
  left: 0;
  height: 60px;
}

#audio-playhead {
  position: absolute;
  top: 0;
  height: 60px;
  width: 2px;
  background: #e94560;
  pointer-events: none;
  display: none;
}

#tl-audio-wave,
#audio-waveform-canvas {
  cursor: default !important;
}

/* 左右分離レイアウト用 */
#timeline-body {
  display: flex;
  height: 100%;
  overflow: hidden;
}

#tl-left-fixed {
  width: 100px;
  flex-shrink: 0;
  overflow-y: auto;
  overflow-x: hidden;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
}

#tl-right-scrollable {
  flex: 1 1 auto;                  /* flex-growを効かせる */
  overflow-y: auto;                /* 縦スクロールは残す */
  overflow-x: visible !important;  /* ← 横ははみ出し許可（重要！） */
  position: relative;
  min-width: 0;                    /* flexの子が縮まないように */
}
/* ヘッダーと行も横に無制限 */
#tl-header,
.tl-row {
  width: auto !important;
  min-width: fit-content !important;
  max-width: none !important;
  display: flex;
  flex-wrap: nowrap;               /* 絶対に折り返さない */
}
/* フレーム番号ヘッダーは横スクロールしても上部に固定 */
#tl-header {
  position: sticky;
  top: 0;
  z-index: 3;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

/* 音声ラベルも左固定側に移動（必要に応じて） */
#tl-audio-label-row {
  position: sticky;
  top: 0;
  z-index: 2;
  background: var(--bg-tertiary);
}

/* 音声波形は右側スクロール領域に追従 */
#tl-audio-row {
  position: relative;
  z-index: 1;
}

.layer-color-btn {
  width: 20px;
  height: 20px;
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 13px;
  cursor: pointer;
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 2px;           /* 👁との間隔 */
}
/* カラーピッカーのポップアップを右側に固定表示するためのラッパー */
#layer-picker-popup {
  position: fixed;
  right: 30px;                /* キャンバス右端から少し内側 */
  top: 100px;                 /* ヘッダー下くらい */
  z-index: 400;
  background: var(--bg-panel);
  border: 1px solid var(--border-light);
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,0.6);
  display: none;
}

#layer-picker-popup.show {
  display: block;
}

#layer-picker-popup .picker-header {
  font-size: 12px;
  color: var(--accent);
  margin-bottom: 8px;
  text-align: center;
}

#layer-picker-popup input[type="color"] {
  width: 180px;
  height: 180px;
  padding: 0;
  border: none;
  cursor: crosshair;
}

.layer-color-btn:hover {
  background: var(--bg-input);
  color: var(--accent);
}



/* レイヤー専用ミニパレット */

#layer-color-palette {
  position: absolute;
  background: var(--bg-panel);
  border: 1px solid var(--border-light);
  border-radius: 6px;
  padding: 8px;
  display: none;
  z-index: 100;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  flex-wrap: wrap;
  gap: 6px;
  width: 160px;
}

#layer-color-palette .color-swatch {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  border: 2px solid #444;
  cursor: pointer;
  transition: all 0.12s;
}

#layer-color-palette .color-swatch:hover {
  transform: scale(1.15);
  box-shadow: 0 0 0 3px rgba(233,69,96,0.4);
}

#layer-color-palette .color-swatch.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 4px rgba(233,69,96,0.3);
}
</style>

</head>
<body>
<div id="header">
  <span class="app-title">✦ Stroke Animation Studio</span>
  <input type="text" id="project-name-input" placeholder="プロジェクト名" value="untitled">
  <div class="header-sep"></div>
  <button class="header-btn" onclick="newProject()">新規</button>
  <button class="header-btn" onclick="saveProject()">💾 保存</button>
  <button class="header-btn" onclick="loadProject()">📂 開く</button>
  <div class="header-sep"></div>
  <button class="header-btn" onclick="showCanvasSizeDialog()">キャンバスサイズ</button>
  <button class="header-btn" onclick="importAudioFile()">🎵 音声読込</button>
  <button class="header-btn" onclick="importDraftImage()">下書き読込</button>
  <button class="header-btn" onclick="importSequenceImages()">📁 連番読込</button>
  <div class="header-sep"></div>
  <button class="header-btn" onclick="undoAction()">↩ 戻す</button>
  <button class="header-btn" onclick="redoAction()">↪ やり直し</button>
  <div class="header-sep"></div>
  <button class="header-btn" onclick="exportAllPNG()">📦 連番PNG出力</button>
</div>

<div id="main-layout">
  <div id="toolbar">
    <button class="tool-btn active" data-tool="pen" title="ペン (P)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"/></svg><span class="shortcut">P</span></button>
    <button class="tool-btn" data-tool="line" title="直線 (L)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg><span class="shortcut">L</span></button>
    <button class="tool-btn" data-tool="circle" title="円形 (C)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg><span class="shortcut">C</span></button>
    <button class="tool-btn" data-tool="rect" title="四角形 (R)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16" rx="1"/></svg><span class="shortcut">R</span></button>
    <div class="tool-sep"></div>
    <button class="tool-btn" data-tool="eraser" title="消しゴム (E)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16l8-8 9 9-4 3z"/><path d="M6.5 13.5l5-5"/></svg><span class="shortcut">E</span></button>
    <div class="tool-sep"></div>
    <button class="tool-btn" data-tool="point" title="ポイント編集 (A)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg><span class="shortcut">A</span></button>
    <button class="tool-btn" data-tool="stroke" title="ストローク編集 (S)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" stroke-dasharray="4 2"/><path d="M7 12h10M12 7v10"/></svg><span class="shortcut">S</span></button>
    <button class="tool-btn" data-tool="move" title="全体移動 (V)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 9l-3 3 3 3"/><path d="M9 5l3-3 3 3"/><path d="M15 19l-3 3-3-3"/><path d="M19 9l3 3-3 3"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg><span class="shortcut">V</span></button>
    <div class="tool-sep"></div>
    <div id="pen-settings">
      <label>サイズ</label><span id="pen-size-val">2</span>
      <input type="range" id="pen-size" min="1" max="30" value="2">
      <label>補正</label><span id="pen-smooth-val">50</span>
      <input type="range" id="pen-smooth" min="0" max="100" value="50">
      <label>色</label><input type="color" id="pen-color" value="#000000">
      
    </div>
    <div id="stroke-point-settings" style="display:none;">
      <label>ポイント数</label><span id="stroke-point-val">-</span>
      <input type="range" id="stroke-point-slider" min="2" max="100" value="10">
    </div>
  </div>

  <div id="canvas-area">
    <div id="canvas-container">
      <div id="canvas-bg"></div>
      <canvas id="onion-canvas" class="canvas-layer"></canvas>
      <canvas id="stroke-guide-canvas" class="canvas-layer"></canvas>
      <canvas id="point-edit-overlay" class="canvas-layer"></canvas>
      <div id="frame-guide-overlay"></div>
    </div>
    <canvas id="stroke-order-overlay"></canvas>
    <div id="rotation-indicator"></div>
    <div id="zoom-indicator">100%</div>
    <div id="cursor-preview"></div>
  </div>

  <div id="right-panel">
    <input type="file" id="imgInput" accept="image/*">
<button id="openPopup">表示</button>

<div id="floatingPopup">
  <div id="popupHeader">Image Viewer</div>
  <div id="popupBody">
    <iframe
  id="popupFrame"
  src="popup.html">
</iframe>
  </div>
  <!-- リサイズハンドル -->
  <div id="resizeHandle"></div>
</div>

<div class="panel-section" style="border-bottom:none; padding-bottom:0;">
  <div class="panel-header" style="font-size:12px; padding:4px 10px;">
    基本カラー
  </div>
  <div class="panel-body" style="padding:6px 10px 2px;">
    <div id="color-palette" style="display:flex; gap:8px; flex-wrap:wrap; justify-content:left;">
      <!-- 黒 -->
      <button class="color-swatch" data-color="#000000" title="黒"></button>
      <!-- 白 -->
      <button class="color-swatch" data-color="#ffffff" title="白"></button>
      <!-- 既存の4色 -->
      <button class="color-swatch" data-color="#e94560" title="赤"></button>
      <button class="color-swatch" data-color="#0000ff" title="青"></button>
      <button class="color-swatch" data-color="#ffff00" title="黄"></button>



      <div class="panel-header" style="font-size:12px; padding:4px 10px;">
    背景透過色
  </div>
  <div id="color-palette-trans" style="display:flex; flex-direction:column; gap:8px; align-items:flex-start;">
  <button class="color-swatch" data-color="#87FF42" title="背景透過"></button>
</div>
  </div>
</div>
<!-- レイヤー情報パネル -->
<div class="panel-section">
  <div class="panel-header">レイヤー情報</div>
  <div class="panel-body">
    <div class="onion-row" style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">
      <label style="width:auto;">作業中のレイヤー:</label>
      <span id="current-layer-name" style="color:var(--text-primary);font-weight:600;margin-left:4px;">-</span>
    </div>
    <div class="onion-row" style="font-size:11px;color:var(--text-secondary);">
      <label style="width:auto;">ストローク数:</label>
      <span id="stroke-count" style="color:var(--text-primary);font-weight:600;margin-left:4px;">0</span>
    </div>
  </div>
</div>

<!-- ストローク情報パネル -->
<div class="panel-section">
  <div class="panel-header">ストローク情報</div>
  <div class="panel-body">
    <div class="onion-row" style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">
      <label style="width:auto;">選択中:</label>
      <span id="selected-stroke-num" style="color:var(--accent);font-weight:600;margin-left:4px;">-</span>
    </div>
    <div class="onion-row" style="font-size:11px;color:var(--text-secondary);">
      <label style="width:auto;">最新:</label>
      <span id="latest-stroke-num" style="color:var(--success);font-weight:600;margin-left:4px;">-</span>
    </div>
    <div style="margin-top:12px;padding-top:8px;border-top:1px solid var(--border);">
      <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;">
        <label style="font-size:10px;color:var(--text-muted);white-space:nowrap;">書き順絞込:</label>
        <input type="number" id="stroke-order-filter" min="1" 
          style="flex:1;background:var(--bg-input);border:1px solid var(--border);color:var(--text-primary);padding:3px 6px;font-size:11px;border-radius:3px;width:50px;"
          placeholder="番号">
        <button id="clear-stroke-filter" 
          style="background:var(--bg-input);border:1px solid var(--border);color:var(--text-secondary);padding:3px 8px;font-size:10px;border-radius:3px;cursor:pointer;"
          title="クリア">×</button>
      </div>
      <div style="font-size:9px;color:var(--text-muted);line-height:1.3;">
        番号を入力してその書き順だけをハイライト表示
      </div>
    </div>
  </div>
</div>
<div class="panel-section">
  <div class="panel-header">音声コントロール</div>
  <div class="panel-body">
    <div class="onion-row">
      <label>音量</label>
      <input type="range" id="audio-volume" min="0" max="150" value="100" style="width:60px;" oninput="updateAudioVolume(this.value)">
      <span id="audio-volume-val" style="font-size:10px;color:var(--text-secondary);margin-left:4px;">100%</span>
    </div>
    <div class="onion-row">
      <button class="layer-action-btn" onclick="toggleAudioMute()" id="audio-mute-btn">🔊 ミュート</button>
      <button class="layer-action-btn" onclick="deleteAudio()">🗑️ 削除</button>
    </div>
    <div id="audio-info" style="font-size:10px;color:var(--text-muted);margin-top:4px;">音声なし</div>
  </div>
</div>

    <div class="panel-section">
      <div class="panel-header">カット管理</div>
      <div class="panel-body" id="cut-list" style="max-height:108px;overflow-y:auto;"></div>
      <div class="cut-actions"><button class="layer-action-btn" onclick="addCut()">追加</button><button class="layer-action-btn" onclick="removeCut()">削除</button></div>
    </div>
    <div class="panel-section">
      <div class="panel-header">レイヤー</div>
      <div class="panel-body" id="layer-list"></div>
      <div class="layer-actions"><button class="layer-action-btn" onclick="clearCurrentLayer()">クリア</button><button class="layer-action-btn" onclick="clearAllLayers()">全クリア</button><button class="layer-action-btn" onclick="duplicateFrame()">複製</button></div>
      <div class="onion-row" style="margin-top:4px;"><label>下書き不透明度</label><input type="range" id="draft-opacity" min="0" max="100" value="40" style="width:60px;" oninput="draftOpacity=this.value/100;document.getElementById('draft-opacity-val').textContent=this.value+'%';renderAll();"><span id="draft-opacity-val" style="font-size:10px;color:var(--text-secondary);margin-left:4px;">40%</span></div>
      <div class="onion-row"><label>オニオン不透明度</label><input type="range" id="onion-opacity" min="0" max="100" value="100" style="width:60px;" oninput="document.getElementById('onion-canvas').style.opacity=this.value/100;document.getElementById('onion-opacity-val').textContent=this.value+'%';"><span id="onion-opacity-val" style="font-size:10px;color:var(--text-secondary);margin-left:4px;">100%</span></div>
    </div>
    <div class="panel-section">
      <div class="panel-header">オニオンスキン</div>
      <div class="panel-body">
        <div class="onion-row"><label>有効</label><input type="checkbox" id="onion-enabled" checked onchange="renderAll()"></div>
        <div class="onion-row"><label>前フレーム数</label><input type="number" id="onion-prev" value="1" min="0" max="5" onchange="renderAll()"></div>
        <div class="onion-row"><label>次フレーム数</label><input type="number" id="onion-next" value="1" min="0" max="5" onchange="renderAll()"></div>
        <div class="onion-row"><label>書き順ガイド</label><input type="checkbox" id="stroke-guide-enabled" onchange="renderAll()"></div>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-header">プロジェクト情報</div>
      <div class="panel-body">
        <div class="onion-row"><label>幅</label><input type="number" id="info-width" value="2600" min="1" max="8192" onchange="applyProjectInfo()"></div>
        <div class="onion-row"><label>高さ</label><input type="number" id="info-height" value="1500" min="1" max="8192" onchange="applyProjectInfo()"></div>
        <div class="onion-row"><label>フレーム数</label><input type="number" id="info-frames" value="24" min="1" max="9999" onchange="applyProjectInfoFrames()"></div>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-header">枠ガイド</div>
      <div class="panel-body">
        <div class="onion-row"><label>表示</label><input type="checkbox" id="frame-guide-enabled" checked onchange="updateFrameGuide()"></div>
        <div class="onion-row"><label>幅</label><input type="number" id="frame-guide-w" value="1920" min="1" max="8192" onchange="updateFrameGuide()"></div>
        <div class="onion-row"><label>高さ</label><input type="number" id="frame-guide-h" value="1080" min="1" max="8192" onchange="updateFrameGuide()"></div>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-header">操作ヘルプ</div>
      <div class="panel-body" style="font-size:10px;color:var(--text-muted);line-height:1.6;">
        Ctrl+Space+ドラッグ/テンキーの+-: 回転<br>ホイール: 拡大縮小<br>Space+ドラッグ: パン<br>
        Ctrl+Z/Y: 元に戻す/やり直し<br>Ctrl+S: 保存<br>→/←: フレーム移動<br>
        右クリック: コピー/ペースト/持続設定<br>Esc: 回転リセット/選択解除<br>
        A: ポイント編集（通過点の移動）<br>S: ストローク編集（選択して移動/拡縮/回転）<br>V: 全体移動<br>
        タイムライン: ドラッグでキーフレーム移動<br>Shift+クリック: 複数選択<br>Del: 選択クリア
      </div>
    </div>
  </div>
</div>

<div id="timeline-panel">
  <div id="timeline-controls">

    <button class="tl-btn" onclick="goFirstFrame()" title="最初">⏮</button>
    <button class="tl-btn" onclick="goPrevFrame()" title="前">◀</button>
    <button class="tl-btn" id="play-btn" onclick="togglePlay()" title="再生/停止">▶</button>
    <button class="tl-btn" onclick="goNextFrame()" title="次">▶</button>
    <button class="tl-btn" onclick="goLastFrame()" title="最後">⏭</button>
    <div class="header-sep"></div>
    <button class="tl-btn" onclick="addFrame()" title="フレーム追加">＋</button>
    <button class="tl-btn" onclick="removeFrame()" title="フレーム削除">－</button>
    <button class="tl-btn" onclick="insertKeyframe()" title="キーフレーム挿入">◆</button>
    <div class="header-sep"></div>
    <span class="tl-info">フレーム: <span id="current-frame-display">1</span>/<span id="total-frame-display">24</span></span>
    <div class="header-sep"></div>
    <span class="tl-info">FPS:</span><input type="number" id="fps-input" value="24" min="1" max="60" onchange="updateFPS()">
    <div class="header-sep"></div>
    <span class="tl-info">カット: <span id="current-cut-display">C_001</span></span>
    <div class="header-sep"></div>
    <button class="header-btn" onclick="clearCurrentLayer()">🗑️ クリア</button>
    <button class="header-btn" onclick="clearAllLayers()">🗑️ 全クリア</button>
    <div class="header-sep"></div>
    <button class="header-btn" onclick="toggleOnionSkin()" title="オニオンスキン">🧅 オニオンスキン</button>
    <button class="header-btn" onclick="showInbetweenDialog()">🎬 自動中割</button>
    <button class="header-btn" onclick="toggleStrokeGuide()">✏️ 書き順ガイド</button>
    
    <div class="header-sep"></div>
    <div id="view-tools">
      <button class="header-btn view-tool-btn" id="vt-pan" onclick="setViewTool('pan')">✋画面移動</button>
      <button class="header-btn view-tool-btn" id="vt-rotate" onclick="setViewTool('rotate')">🔁キャンバス回転</button>
      <button class="header-btn view-tool-btn" id="vt-reset-rot" onclick="S.rot=0;updateTransform();">🔂回転リセット</button>
      <button class="header-btn view-tool-btn" id="vt-fit" onclick="centerCanvas()">🪟フィット</button>
      <span style="font-size:11px;">🔍</span>
      <input type="range" id="zoom-slider" min="10" max="500" value="100" title="ズーム" style="width:120px;" oninput="applyZoomSlider(this.value)">
      <span id="zoom-slider-val" style="font-size:10px;color:var(--text-secondary);min-width:28px;">100%</span>
      <div style="margin:0 8px; display:flex; align-items:center; gap:12px; flex-wrap:nowrap; white-space:nowrap;">
    <label style="display:flex; align-items:center; gap:6px; cursor:pointer; user-select:none; min-width:max-content;">
      <input type="checkbox" id="snap-enabled-checkbox" checked onchange="toggleSnapEnabled()">
      <span style="font-size:11px;">端点を吸着</span>
    </label>

    <!-- スライダー本体（チェックボックスの右隣） -->
    <div id="snap-distance-wrapper" style="display:flex; align-items:center; gap:8px; font-size:11px; color:var(--text-secondary);">
      <span>(</span>
      <input type="range" id="snap-distance-slider" min="2" max="10" value="3" step="1" style="width:100px; flex:1;">
      <span id="snap-distance-val" style="min-width:30px; text-align:right;">3</span>
      <span>px以内)</span>
    </div>
  </div>

  <!-- 全体吸着は下に -->
  <label id="snap-full-stroke-label" style="display:none; align-items:center; gap:6px; cursor:pointer; user-select:none; margin-left:20px; font-size:10px; color:var(--text-muted);">
    <input type="checkbox" id="snap-full-stroke-checkbox" onchange="toggleSnapFullStroke()">
    <span>ストローク全体にも吸着</span>
  </label>
    </div>
    
  </div>
  <div id="timeline-body" style="display: flex; height: 100%; overflow: hidden;">

  <!-- 左側：固定（レイヤー名 + 音声ラベル） -->
  <div id="tl-left-fixed" style="width: 100px; flex-shrink: 0; overflow-y: auto; overflow-x: hidden; background: var(--bg-secondary); border-right: 1px solid var(--border);">
    <div id="tl-layer-labels">
      <div id="tl-layer-labels-inner"></div>
    </div>
    <!-- 音声ラベルはここに固定で入れる -->
    <div id="tl-audio-label-row" class="tl-layer-label" style="height:24px; background:var(--bg-tertiary); font-weight:bold; border-bottom:1px solid var(--border);">
      <span class="dot" style="background:#e94560; margin-right:6px;"></span>音声
    </div>
  </div>

  <!-- 右側：スクロール可能（フレームヘッダー + セル + 音声波形） -->
  <div id="tl-right-scrollable" style="flex: 1; overflow: auto; position: relative;">
    <div id="tl-frames-area">
      <div id="tl-header"></div>
      <div id="tl-rows"></div>
      <!-- 音声波形行はここ（最下部）に固定配置 -->
      <!-- 元の波形部分をコメントアウトまたは削除して、以下のようにシンプルに -->
<div id="tl-audio-row" style="height:24px; background:var(--bg-secondary); border-bottom:1px solid var(--border); position:sticky; bottom:0; z-index:1; width:100%; min-width:fit-content; display:flex; align-items:center; padding-left:8px;">
  <div style="color:#e94560; font-weight:bold; font-size:11px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:180px;" id="audio-filename-display">
    音声なし
  </div>
  <div style="margin-left:12px; font-size:10px; color:var(--text-muted);" id="audio-duration-display">
    <!-- 長さとか表示したい場合はここ -->
  </div>
</div>
    </div>
  </div>

</div>
<!-- コンテキストメニュー -->
<div id="ctx-menu">
  <div class="ctx-item" onclick="ctxCopyFrame()">📋 フレームをコピー<span class="ctx-shortcut">Ctrl+C</span></div>
  <div class="ctx-item" id="ctx-paste" onclick="ctxPasteFrame()">📌 フレームを貼り付け<span class="ctx-shortcut">Ctrl+V</span></div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" onclick="ctxCopyAllLayers()">📋 全レイヤーコピー</div>
  <div class="ctx-item" id="ctx-paste-all" onclick="ctxPasteAllLayers()">📌 全レイヤー貼り付け</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" onclick="ctxClearFrame()">🗑️ フレームをクリア</div>
  <div class="ctx-item" onclick="ctxInsertFrame()">◆ キーフレーム挿入</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" onclick="ctxSetDuration()">⏱️ 持続フレーム設定...</div>
</div>

<div class="modal-overlay" id="canvas-size-modal">
  <div class="modal-box"><h3>キャンバスサイズ</h3>
    <div class="modal-row"><label>幅:</label><input type="number" id="canvas-w-input" value="2600" min="1" max="8192"></div>
    <div class="modal-row"><label>高さ:</label><input type="number" id="canvas-h-input" value="1500" min="1" max="8192"></div>
    <div class="modal-buttons"><button class="modal-btn secondary" onclick="closeModal('canvas-size-modal')">キャンセル</button><button class="modal-btn primary" onclick="applyCanvasSize()">適用</button></div>
  </div>
</div>
<div class="modal-overlay" id="inbetween-dialog">
  <div class="modal-box" style="min-width:360px;"><h3>🎬 自動中割生成</h3>
    <div class="modal-row"><label>開始フレーム:</label><input type="number" id="inb-start" value="1" min="1"></div>
    <div class="modal-row"><label>終了フレーム:</label><input type="number" id="inb-end" value="2" min="1"></div>
    <div class="modal-row"><label>挿入枚数:</label><input type="number" id="inb-count" value="3" min="1" max="30"></div>
    <div class="modal-row"><label>イージング:</label><select id="inb-easing"><option value="linear">リニア</option><option value="easeIn">イーズイン</option><option value="easeOut">イーズアウト</option><option value="easeInOut">イーズインアウト</option></select></div>
    
    
    <canvas id="inbetween-preview"></canvas>
    <div class="modal-buttons"><button class="modal-btn secondary" onclick="closeModal('inbetween-dialog')">キャンセル</button><button class="modal-btn primary" onclick="generateInbetweens()">生成</button></div>
  </div>
</div>
<div class="modal-overlay" id="duration-modal">
  <div class="modal-box" style="min-width:240px;"><h3>⏱️ 持続フレーム設定</h3>
    <div class="modal-row"><label>フレーム数:</label><input type="number" id="dur-modal-input" value="1" min="1" max="100"></div>
    <div class="modal-buttons"><button class="modal-btn secondary" onclick="closeModal('duration-modal')">キャンセル</button><button class="modal-btn primary" onclick="applyDurModal()">適用</button></div>
  </div>
</div>

<div id="export-progress"><h4>📦 連番PNG書き出し中...</h4><div id="export-progress-bar"><div id="export-progress-fill"></div></div><div id="export-progress-text">0 / 0</div></div>
<div id="notification"></div>
<input type="file" id="file-input-project" accept=".json,.sasp" style="display:none" onchange="handleLoadProject(event)">
<input type="file" id="file-input-draft" accept="image/*" style="display:none" onchange="handleDraftImage(event)">
<input type="file" id="file-input-sequence" accept="image/*" multiple style="display:none" onchange="handleSequenceImages(event)">
<input type="file" id="file-input-audio" accept="audio/*" style="display:none" onchange="handleAudioFile(event)">
<script>
const LAYER_DEFS = [
  // 表示名「原画1」だが、実際は一番手前（インデックス0）
  {id:'draw1_ui', name:'原画1', color:'var(--layer-color-1)', type:'draw'},  // 元の原画4と同じ色
  {id:'draw2_ui', name:'原画2', color:'var(--layer-color-2)', type:'draw'},
  {id:'draw3_ui', name:'原画3', color:'var(--layer-color-3)', type:'draw'},
  {id:'draw4_ui', name:'原画4', color:'var(--layer-color-4)', type:'draw'},  // 元の原画1と同じ色

  // 下書きも同様に名前を逆転
  {id:'draft1_ui', name:'下書き1', color:'var(--draft-color-4)', type:'draft'},  // 元の下書き4の色
  {id:'draft2_ui', name:'下書き2', color:'var(--draft-color-3)', type:'draft'},
  {id:'draft3_ui', name:'下書き3', color:'var(--draft-color-2)', type:'draft'},
  {id:'draft4_ui', name:'下書き4', color:'var(--draft-color-1)', type:'draft'},  // 元の下書き1の色
];

let cuts=[];let currentCut=0;
let S={cw:2600,ch:1500,fps:24,frame:0,layer:0,tool:'pen',penSize:2,penColor:'#000000',penSmooth:50,zoom:1,rot:0,panX:0,panY:0,playing:false,playTimer:null};
// 音声管理
let audioBuffer = null;
let audioSource = null;
let audioContext = null;
let audioGainNode = null;
let audioState = {
  file: null,
  volume: 100,
  muted: false,
  duration: 0,
  startFrame: 0,
  currentOffset: 0,   // ← ここに追加しても良い
};
let layerVis={};let undoStack=[],redoStack=[];const MAX_UNDO=50;
let layerCanvases=[],layerCtxs=[];
let onionCanvas,onionCtx,guideCanvas,guideCtx,overlayCanvas,overlayCtx;
let onionLayerVis={}; // オニオンスキンのレイヤーごと表示フラグ
let drawing=false,panning=false,rotating=false;
let curPoints=[],shapeStart=null,lastMouse={x:0,y:0};
let drawingSnapshot=null; // 描画開始時のレイヤーcanvasスナップショット
let spaceHeld=false,ctrlHeld=false;
let draftImgCache={};let strokeGuideVisible=false;
let draftOpacity=0.4; // 下書きレイヤー不透明度
let frameGuideW=1920,frameGuideH=1080; // 枠ガイドサイズ
let viewTool=''; // '' | 'pan' | 'rotate' （空=通常描画モード）
let strokeOrderFilter = null; // 書き順フィルター（nullまたは数値）
let snapEnabled=true; // ★ ストローク端点吸着の有効/無効フラグ
let snapFullStroke = false;  // ストローク全体吸着のON/OFF
let snapDistance = 3;  // 初期値 3px

// ★ ポップアップ画像管理用プロジェクトオブジェクト
let project={popupImages:[]};

// クリップボード（フレームコピー用）
let clipFrame=null;       // 単一レイヤー {strokes, draftImg}
let clipAllFrames=null;   // 全レイヤー [{strokes, draftImg}, ...]
// コンテキストメニュー対象
let ctxLayer=-1,ctxFrame=-1;

// ポイント編集ツール用
let pointEditCanvas,pointEditCtx;
let selectedStrokeIdx=-1;   // 選択中のストロークindex
let dragPointInfo=null;     // {strokeIdx, type, idx, sub} ドラッグ中の制御点情報
let selectedPointInfo=null; // 選択中のポイント情報（ハンドル表示用、mouseup後も保持）
let POINT_RADIUS=5;         // 制御点の表示半径（canvas座標）

// 移動ツール用
let moveMode='all';         // 'all' | 'single'
let moveDragging=false;
let moveDragStart=null;     // {x, y}
let moveTargetIdx=-1;       // single時のストロークindex

// ストローク編集ツール用
let strokeEditIdx=-1;       // 選択中ストロークindex
let strokeEditMode='';      // '' | 'move' | 'scale' | 'rotate'
let strokeEditStart=null;   // ドラッグ開始座標
let strokeEditAnchor=null;  // 回転アンカー {x,y} クリック位置
let strokeEditInitAngle=0;  // 初期角度（回転用）
let strokeEditInitScale=1;  // 初期距離（拡縮用）
// ボックス状態: 4頂点で管理（回転対応）
let strokeEditCorners=null; // [tl,tr,br,bl] 各{x,y}
let strokeEditCenter=null;  // {x,y} ボックス中心

// タイムラインキーフレームドラッグ用
let tlSelected=new Set();   // 選択中セル Set of 'li-fi' strings
let tlDragging=false;
let tlDragSource=null;      // {li,fi} ドラッグ開始セル
let tlDragCurrent=null;     // 現在マウス下のフレームindex
let tlDragOffset=0;         // ドラッグ開始位置からのオフセット

function CC(){return cuts[currentCut];}
function CF(){return CC().layers;}
function CTF(){return CC().totalFrames;}
function CFD(){return CC().frameDur;}

// 持続フレーム対応：fi位置で実際に表示すべきフレームインデックスを返す
// frameDur[li+'-'+f]がd(>=2)なら f～f+d-1 の範囲はfのデータを表示
function getEffectiveFrameIdx(li,fi){
  const dur=CFD();
  for(let f=fi;f>=0;f--){
    const d=dur[li+'-'+f]||1;
    if(d>1&&fi>=f&&fi<=f+d-1)return f;
  }
  return fi;
}
function getEffectiveFrame(li,fi){
  const eidx=getEffectiveFrameIdx(li,fi);
  const frames=CF()[li].frames;
  if(eidx<0||eidx>=frames.length)return null;
  return frames[eidx];
}
// =============================================
// スポイトモード（EyeDropper API版：画面全体対応 + 既存機能互換）
// =============================================
function startEyedropperMode() {
  // 現在のツールとカーソルを記憶
  const previousTool = S.tool;
  const previousCursor = document.getElementById('canvas-area').style.cursor;

  // スポイトモードに切り替え
  S.tool = 'eyedropper';
  document.getElementById('canvas-area').style.cursor = 'crosshair';

  notify('スポイトモード：画面上の好きな場所をクリックしてください（Escでキャンセル）');

  // cleanup関数（1回だけ定義）
  const cleanup = () => {
    document.removeEventListener('keydown', onKeyEsc);
    S.tool = previousTool;
    document.getElementById('canvas-area').style.cursor = previousCursor;
    selectTool(previousTool);
  };

  // Escキーでのキャンセル
  const onKeyEsc = (e) => {
    if (e.key === 'Escape') {
      notify('スポイトをキャンセルしました');
      cleanup();
    }
  };

  document.addEventListener('keydown', onKeyEsc);

  // ── EyeDropper が使える場合 ──
  if (window.EyeDropper) {
    const eyeDropper = new EyeDropper();

    eyeDropper.open()
      .then(result => {
        const hex = result.sRGBHex;

        S.penColor = hex;
        document.getElementById('pen-color').value = hex;
        updateActiveColorButton();

        notify(`色を ${hex} に設定しました`);

        cleanup();
      })
      .catch(err => {
        // ★ ここを変更：失敗通知を一切出さない（キャンセル時は静かに終了）
        // 実際の失敗（権限エラーなど）は稀なのでログだけ残す
        if (err.name !== 'NotAllowedError' && err.name !== 'AbortError') {
          console.warn('EyeDropper エラー（無視）:', err);
        }
        // キャンセル時は通知なしで終了
        cleanup();
      });
  }
  // ── EyeDropper が使えない場合 → 従来のキャンバス内スポイト ──
  else {
    notify('画面全体スポイト非対応のため、キャンバス内のみから色を取ります');

    const onClick = (e) => {
      const pos = getPos(e);
      const ctx = layerCtxs[S.layer];

      const pixel = ctx.getImageData(
        Math.floor(pos.x),
        Math.floor(pos.y),
        1, 1
      ).data;

      const r = pixel[0].toString(16).padStart(2, '0');
      const g = pixel[1].toString(16).padStart(2, '0');
      const b = pixel[2].toString(16).padStart(2, '0');
      const hex = '#' + r + g + b;

      S.penColor = hex;
      document.getElementById('pen-color').value = hex;
      updateActiveColorButton();

      notify(`色を ${hex} に設定しました`);

      cleanup();
    };

    document.getElementById('canvas-area').addEventListener('click', onClick, { once: true });
  }
}
// ===========================================================
// 初期化
// ===========================================================
function init(){
  cuts.push(createEmptyCut('C_001',24));
  for(let i=0;i<LAYER_DEFS.length;i++){layerVis[i]=true;onionLayerVis[i]=true;}
  createCanvases();updateCutList();updateLayerList();updateTimeline();updateTransform();
  function initSnapDistanceUI() {
    console.log("[DEBUG] initSnapDistanceUI が呼ばれました");

    const slider = document.getElementById('snap-distance-slider');
    const val    = document.getElementById('snap-distance-val');
    const wrapper = document.getElementById('snap-distance-wrapper');

    if (!slider || !val || !wrapper) {
      console.error("[ERROR] スライダー関連の要素が見つかりません");
      console.log("slider:", slider);
      console.log("val:", val);
      console.log("wrapper:", wrapper);
      return;
    }

    console.log("[DEBUG] スライダー要素発見");

    // 初期値反映
    slider.value = snapDistance;
    val.textContent = snapDistance;

    // スライダー変更
    slider.addEventListener('input', (e) => {
      snapDistance = +e.target.value;
      val.textContent = snapDistance;
      console.log("snapDistance が変更されました →", snapDistance);
    });

    // チェックボックス連動
    const cb = document.getElementById('snap-enabled-checkbox');
    if (cb) {
      const updateVisibility = () => {
        snapEnabled = cb.checked;
        if (wrapper) {
          wrapper.style.opacity = snapEnabled ? '1' : '0.4';
          wrapper.style.pointerEvents = snapEnabled ? 'auto' : 'none';
        }
        // 全体吸着ラベルも連動
        const fullLabel = document.getElementById('snap-full-stroke-label');
        if (fullLabel) {
          fullLabel.style.display = snapEnabled ? 'flex' : 'none';
        }
        console.log("[DEBUG] snapEnabled 変更 →", snapEnabled);
      };

      cb.addEventListener('change', updateVisibility);
      updateVisibility(); // 初回反映（超重要！）
    } else {
      console.warn("[WARN] snap-enabled-checkbox が見つかりません");
    }
  }

  // ★ 必ずここで呼ぶ
  initSnapDistanceUI();

  renderAll();setupEvents();centerCanvas();
  // ★ 追加: 吸着チェックボックスの初回表示同期
toggleSnapEnabled();
initSnapDistanceSlider();      // ← 追加！
// 書き順フィルターのイベント設定
const filterInput = document.getElementById('stroke-order-filter');
const clearBtn = document.getElementById('clear-stroke-filter');

if (filterInput) {
  filterInput.addEventListener('input', (e) => {
    const val = e.target.value.trim();
    if (val === '' || val === '0') {
      strokeOrderFilter = null;
    } else {
      strokeOrderFilter = parseInt(val, 10);
    }
    renderAll();
  });
  
  // Enterキーでもフォーカス外してプレビュー
  filterInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.target.blur();
    }
  });
}

if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    strokeOrderFilter = null;
    if (filterInput) filterInput.value = '';
    renderAll();
  });
}

}

function initSnapDistanceSlider() {
  const slider = document.getElementById('snap-distance-slider');
  const valDisplay = document.getElementById('snap-distance-val');

  if (!slider || !valDisplay) return;

  // 初期値反映
  slider.value = snapDistance;
  valDisplay.textContent = snapDistance + ' px';

  // スライダー変更時
  slider.addEventListener('input', (e) => {
    snapDistance = +e.target.value;
    valDisplay.textContent = snapDistance + ' px';
    
    // 必要なら即時通知（好みで）
    // notify(`吸着距離を ${snapDistance}px に変更`);
  });
}
function createEmptyCut(name,frames){
  const c={name,totalFrames:frames,frameDur:{},layers:[]};
  for(let i=0;i<LAYER_DEFS.length;i++){c.layers.push({frames:[]});for(let f=0;f<frames;f++)c.layers[i].frames.push({strokes:[],draftImg:null});}
  return c;
}
function createCanvases(){
  const ct = document.getElementById('canvas-container');
  layerCanvases.forEach(c => c.remove());
  layerCanvases = [];
  layerCtxs = [];

  const bg = document.getElementById('canvas-bg');
  bg.style.width = S.cw + 'px';
  bg.style.height = S.ch + 'px';

  onionCanvas = document.getElementById('onion-canvas');
  onionCanvas.width = S.cw; onionCanvas.height = S.ch;
  onionCtx = onionCanvas.getContext('2d');

  guideCanvas = document.getElementById('stroke-guide-canvas');
  guideCanvas.width = S.cw; guideCanvas.height = S.ch;
  guideCtx = guideCanvas.getContext('2d');

  pointEditCanvas = document.getElementById('point-edit-overlay');
  pointEditCanvas.width = S.cw; pointEditCanvas.height = S.ch;
  pointEditCtx = pointEditCanvas.getContext('2d');

  overlayCanvas = document.getElementById('stroke-order-overlay');
  overlayCanvas.width = S.cw; overlayCanvas.height = S.ch;
  overlayCtx = overlayCanvas.getContext('2d');

  // ★★★ ここを逆順に変更 ★★★
  // 下書き4 → … → 原画1 の順でDOMに追加 → 原画1が一番手前になる
  for(let i = LAYER_DEFS.length - 1; i >= 0; i--){
    const c = document.createElement('canvas');
    c.className = 'canvas-layer';
    c.width = S.cw;
    c.height = S.ch;
    c.style.width = S.cw + 'px';
    c.style.height = S.ch + 'px';
    ct.appendChild(c);           // ← ここで追加する順が重要
    layerCanvases.push(c);
    const ctx = c.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    layerCtxs.push(ctx);
  }

  // layerCanvases と layerCtxs の順番は LAYER_DEFS と一致させるために reverse
  layerCanvases.reverse();
  layerCtxs.reverse();
}
function centerCanvas(){
  const a=document.getElementById('canvas-area').getBoundingClientRect();
  const tlPanel=document.getElementById('timeline-panel');
  const tlH=tlPanel?tlPanel.offsetHeight:0;
  const viewH=a.height-tlH;
  const viewW=a.width;
  // 縦幅にフィット（タイムラインの手前まで）
  const fitZoom=viewH/S.ch;
  S.zoom=fitZoom;
  S.rot=0;
  S.panX=(viewW-S.cw*S.zoom)/2;
  S.panY=0;
  updateTransform();
}
function updateTransform(){
  // キャンバス中心を軸に回転: translate(pan) → translate(center) → rotate → translate(-center) → scale
  const cx=S.cw*S.zoom/2, cy=S.ch*S.zoom/2;
  document.getElementById('canvas-container').style.transform=
    `translate(${S.panX}px,${S.panY}px) translate(${cx}px,${cy}px) rotate(${S.rot}deg) translate(${-cx}px,${-cy}px) scale(${S.zoom})`;
  document.getElementById('zoom-indicator').textContent=Math.round(S.zoom*100)+'%';
  const zs=document.getElementById('zoom-slider');
  if(zs)zs.value=Math.round(S.zoom*100);
  const zv=document.getElementById('zoom-slider-val');
  if(zv)zv.textContent=Math.round(S.zoom*100)+'%';
}

function setViewTool(t){
  viewTool=(viewTool===t)?'':t;
  document.querySelectorAll('.view-tool-btn').forEach(b=>b.classList.remove('active'));
  if(viewTool==='pan')document.getElementById('vt-pan').classList.add('active');
  if(viewTool==='rotate')document.getElementById('vt-rotate').classList.add('active');
}
function applyZoomSlider(v){
  const newZoom=Math.max(0.1,Math.min(10,v/100));
  const a=document.getElementById('canvas-area').getBoundingClientRect();
  const cx=a.width/2,cy=a.height/2;
  const oldZoom=S.zoom;
  S.panX=cx-(cx-S.panX)*(newZoom/oldZoom);
  S.panY=cy-(cy-S.panY)*(newZoom/oldZoom);
  S.zoom=newZoom;
  updateTransform();
}

// ===========================================================
// イベント
// ===========================================================
function setupEvents(){
  const area=document.getElementById('canvas-area');
  area.addEventListener('mousedown',onDown);area.addEventListener('mousemove',onMove);area.addEventListener('mouseup',onUp);area.addEventListener('mouseleave',onUp);
  area.addEventListener('wheel',onWheel,{passive:false});area.addEventListener('contextmenu',e=>e.preventDefault());

  // タッチイベント：スタイラス(pen)のみ描画、指(touch)はビュー操作
  let stylusId=null;
  let fingerTouches=[];  // 指タッチ管理
  let lastFingerPos=null; // 1本指パン用
  let lastPinchDist=0,lastPinchAngle=0,lastPinchCenter=null;

  area.addEventListener('touchstart',e=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(t.touchType==='stylus'||e.touches.length===1&&(t.radiusX<5&&t.radiusY<5)){
        // スタイラス判定（touchType対応ブラウザ or 小さい接触面積）
        // PointerEventsで補完するため、ここでは簡易判定
      }
    }
    // PointerEventsに委譲（下のpointerイベントで処理）
  },{passive:false});

  // PointerEvents：pen/mouse → 描画、touch → ビュー操作
  let pointerId=null;
  area.addEventListener('pointerdown',e=>{
    if(e.pointerType==='touch'){
      // 指タッチ → ビュー操作
      fingerTouches.push({id:e.pointerId,x:e.clientX,y:e.clientY});
      if(fingerTouches.length===1){
        lastFingerPos={x:e.clientX,y:e.clientY};
      }else if(fingerTouches.length===2){
        // ピンチ/回転開始
        const dx=fingerTouches[0].x-fingerTouches[1].x,dy=fingerTouches[0].y-fingerTouches[1].y;
        lastPinchDist=Math.sqrt(dx*dx+dy*dy);
        lastPinchAngle=Math.atan2(dy,dx);
        lastPinchCenter={x:(fingerTouches[0].x+fingerTouches[1].x)/2,y:(fingerTouches[0].y+fingerTouches[1].y)/2};
      }
      return;
    }
    // ペン/マウス → ビューツール確認
    if(viewTool==='pan'){
      panning=true;lastMouse={x:e.clientX,y:e.clientY};
      pointerId=e.pointerId;return;
    }
    if(viewTool==='rotate'){
      rotating=true;lastMouse={x:e.clientX,y:e.clientY};
      document.getElementById('rotation-indicator').style.display='block';
      pointerId=e.pointerId;return;
    }
    // 通常描画
    pointerId=e.pointerId;
    onDown({clientX:e.clientX,clientY:e.clientY,button:e.button,preventDefault(){}});
  });
  area.addEventListener('pointermove',e=>{
    if(e.pointerType==='touch'){
      // 指の位置更新
      for(let i=0;i<fingerTouches.length;i++){
        if(fingerTouches[i].id===e.pointerId){
          fingerTouches[i].x=e.clientX;fingerTouches[i].y=e.clientY;break;
        }
      }
      if(fingerTouches.length===1&&lastFingerPos){
        // 1本指パン
        S.panX+=e.clientX-lastFingerPos.x;S.panY+=e.clientY-lastFingerPos.y;
        lastFingerPos={x:e.clientX,y:e.clientY};
        updateTransform();
      }else if(fingerTouches.length===2){
        // 2本指ピンチ＋回転
        const dx=fingerTouches[0].x-fingerTouches[1].x,dy=fingerTouches[0].y-fingerTouches[1].y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        const angle=Math.atan2(dy,dx);
        const center={x:(fingerTouches[0].x+fingerTouches[1].x)/2,y:(fingerTouches[0].y+fingerTouches[1].y)/2};
        if(lastPinchDist>0){
          // ズーム（ピンチ中心基準）
          const a=document.getElementById('canvas-area').getBoundingClientRect();
          const mx=center.x-a.left,my=center.y-a.top;
          const oldZoom=S.zoom;
          S.zoom=Math.max(0.1,Math.min(10,S.zoom*(dist/lastPinchDist)));
          S.panX=mx-(mx-S.panX)*(S.zoom/oldZoom);
          S.panY=my-(my-S.panY)*(S.zoom/oldZoom);
          // 回転
          const da=(angle-lastPinchAngle)*180/Math.PI;
          S.rot+=da;
          // パン
          if(lastPinchCenter){
            S.panX+=center.x-lastPinchCenter.x;
            S.panY+=center.y-lastPinchCenter.y;
          }
          updateTransform();
        }
        lastPinchDist=dist;lastPinchAngle=angle;lastPinchCenter=center;
      }
      return;
    }
    if(e.pointerId!==pointerId)return;
    if(panning){S.panX+=e.clientX-lastMouse.x;S.panY+=e.clientY-lastMouse.y;lastMouse={x:e.clientX,y:e.clientY};updateTransform();return;}
    if(rotating){S.rot+=(e.clientX-lastMouse.x)*0.5;lastMouse={x:e.clientX,y:e.clientY};document.getElementById('rotation-indicator').textContent=Math.round(S.rot)+'°';updateTransform();return;}
    onMove({clientX:e.clientX,clientY:e.clientY,preventDefault(){}});
  });
  const pointerUp=e=>{
    if(e.pointerType==='touch'){
      fingerTouches=fingerTouches.filter(f=>f.id!==e.pointerId);
      if(fingerTouches.length<2){lastPinchDist=0;lastPinchAngle=0;lastPinchCenter=null;}
      if(fingerTouches.length===0)lastFingerPos=null;
      else if(fingerTouches.length===1)lastFingerPos={x:fingerTouches[0].x,y:fingerTouches[0].y};
      return;
    }
    if(e.pointerId!==pointerId)return;
    if(panning){panning=false;pointerId=null;return;}
    if(rotating){rotating=false;document.getElementById('rotation-indicator').style.display='none';pointerId=null;return;}
    pointerId=null;
    onUp({clientX:e.clientX,clientY:e.clientY,preventDefault(){}});
  };
  area.addEventListener('pointerup',pointerUp);area.addEventListener('pointercancel',pointerUp);
  area.addEventListener('pointerleave',e=>{if(e.pointerType!=='touch')pointerUp(e);});
  // タッチのデフォルト動作を完全に抑制
  area.addEventListener('touchstart',e=>e.preventDefault(),{passive:false});
  area.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});

  document.addEventListener('keydown',onKeyDown);document.addEventListener('keyup',onKeyUp);
  document.getElementById('pen-size').addEventListener('input',e=>{S.penSize=+e.target.value;document.getElementById('pen-size-val').textContent=S.penSize;});
  document.getElementById('pen-smooth').addEventListener('input',e=>{S.penSmooth=+e.target.value;document.getElementById('pen-smooth-val').textContent=S.penSmooth;});
  document.getElementById('pen-color').addEventListener('input',e=>{S.penColor=e.target.value;});
  document.getElementById('stroke-point-slider').addEventListener('input',onStrokePointSliderInput);
  // ツールボタンのイベントリスナー（修正版：より堅牢に）
  document.querySelectorAll('.tool-btn[data-tool]').forEach(b=>{
    b.addEventListener('click',(e)=>{
      e.preventDefault();
      e.stopPropagation();
      const tool = b.dataset.tool;
      if(tool){
        selectTool(tool);
      }
    });
  });
  area.addEventListener('mousemove',e=>{const cp=document.getElementById('cursor-preview');const sz=S.penSize*S.zoom;cp.style.width=sz+'px';cp.style.height=sz+'px';cp.style.left=(e.clientX-sz/2)+'px';cp.style.top=(e.clientY-sz/2)+'px';});
  area.addEventListener('mouseenter',()=>{if(S.tool!=='point'&&S.tool!=='move'&&S.tool!=='stroke')document.getElementById('cursor-preview').style.display='block';});
  area.addEventListener('mouseleave',()=>{document.getElementById('cursor-preview').style.display='none';});
  // コンテキストメニューを閉じる＆タイムライン選択解除
  document.addEventListener('click',e=>{
    hideCtxMenu();
    // タイムラインセル外クリックで選択解除（モーダル内は除外）
    if(!e.target.closest('.tl-cell')&&!e.target.closest('#ctx-menu')&&!e.target.closest('.modal-overlay')&&tlSelected.size>0){
      tlSelected.clear();updateTimeline();
    }
  });
  document.addEventListener('contextmenu',e=>{const m=document.getElementById('ctx-menu');if(m.style.display==='block'&&!m.contains(e.target))hideCtxMenu();});
}
function getPos(e){
  const a=document.getElementById('canvas-area').getBoundingClientRect();
  const ax=e.clientX-a.left,ay=e.clientY-a.top;
  // CSS: translate(pan) → translate(cx,cy) → rotate → translate(-cx,-cy) → scale
  // 逆順: scale⁻¹ → translate(cx,cy) → rotate⁻¹ → translate(-cx,-cy) → translate(-pan)
  // step1: translate(pan)逆
  const tx=ax-S.panX,ty=ay-S.panY;
  // step2: translate(cx,cy)逆
  const cx=S.cw*S.zoom/2, cy=S.ch*S.zoom/2;
  const rx=tx-cx,ry=ty-cy;
  // step3: rotate逆
  const rad=-S.rot*Math.PI/180,cos=Math.cos(rad),sin=Math.sin(rad);
  const rrx=cos*rx-sin*ry,rry=sin*rx+cos*ry;
  // step4: translate(-cx,-cy)逆 → +cx,+cy
  const sx=rrx+cx,sy=rry+cy;
  // step5: scale逆
  return{x:sx/S.zoom,y:sy/S.zoom};
}
function onDown(e){
  if(e.button===1){panning=true;lastMouse={x:e.clientX,y:e.clientY};return;}
  if(spaceHeld&&ctrlHeld){rotating=true;lastMouse={x:e.clientX,y:e.clientY};document.getElementById('rotation-indicator').style.display='block';return;}
  if(spaceHeld||viewTool==='pan'){panning=true;lastMouse={x:e.clientX,y:e.clientY};return;}
  if(viewTool==='rotate'){rotating=true;lastMouse={x:e.clientX,y:e.clientY};document.getElementById('rotation-indicator').style.display='block';return;}
  if(e.button!==0)return;const p=getPos(e);

  // ポイント編集ツール
  if(S.tool==='point'){onDownPoint(p,e);return;}
  // ストローク編集ツール
  if(S.tool==='stroke'){onDownStroke(p,e);return;}
  // 移動ツール
  if(S.tool==='move'){onDownMove(p,e);return;}

  if(S.tool==='pen'){drawing=true;curPoints=[{x:p.x,y:p.y}];pushUndo();drawingSnapshot=layerCtxs[S.layer].getImageData(0,0,S.cw,S.ch);}
  else if(S.tool==='eraser'){drawing=true;curPoints=[{x:p.x,y:p.y}];pushUndo();drawingSnapshot=null;}
  else if(S.tool==='line'||S.tool==='circle'||S.tool==='rect'){drawing=true;shapeStart={x:p.x,y:p.y};pushUndo();drawingSnapshot=layerCtxs[S.layer].getImageData(0,0,S.cw,S.ch);}
}
function onMove(e){
  if(panning){S.panX+=e.clientX-lastMouse.x;S.panY+=e.clientY-lastMouse.y;lastMouse={x:e.clientX,y:e.clientY};updateTransform();return;}
  if(rotating){S.rot+=(e.clientX-lastMouse.x)*0.5;lastMouse={x:e.clientX,y:e.clientY};document.getElementById('rotation-indicator').textContent=Math.round(S.rot)+'°';updateTransform();return;}

  const p=getPos(e);
  // ポイント編集ツール
  if(S.tool==='point'){onMovePoint(p,e);return;}
  // ストローク編集ツール
  if(S.tool==='stroke'){onMoveStroke(p,e);return;}
  // 移動ツール
  if(S.tool==='move'){onMoveMove(p,e);return;}

  if(!drawing)return;
  if(S.tool==='pen'||S.tool==='eraser'){curPoints.push({x:p.x,y:p.y});renderStrokePreview();}else renderShapePreview(p);
}
function onUp(e){
  if(panning){panning=false;return;}if(rotating){rotating=false;document.getElementById('rotation-indicator').style.display='none';return;}

  const p=getPos(e);
  // ポイント編集ツール
  if(S.tool==='point'){onUpPoint(p,e);return;}
  // ストローク編集ツール
  if(S.tool==='stroke'){onUpStroke(p,e);return;}
  // 移動ツール
  if(S.tool==='move'){onUpMove(p,e);return;}

  if(!drawing)return;drawing=false;const fr=CF()[S.layer].frames[S.frame];
  if(S.tool==='pen'&&curPoints.length>=2){
    const sm=smoothPoints(curPoints);
    const newStroke = {type:'bezier',controls:toBezier(sm),color:S.penColor,size:S.penSize,order:fr.strokes.length};
    // ★ 吸着が有効な場合、すべてのレイヤーの既存ストロークに吸着
    if(snapEnabled){
      // すべてのレイヤーのストロークを収集
      const allStrokes = [];
      CF().forEach(layer => {
        if(layer.frames[S.frame] && layer.frames[S.frame].strokes){
          allStrokes.push(...layer.frames[S.frame].strokes);
        }
      });
      const snapped = snapNewStrokeToExisting(newStroke, allStrokes, snapDistance, snapFullStroke);
      fr.strokes.push(snapped);
    } else {
      fr.strokes.push(newStroke);
    }
  }
  else if(S.tool==='eraser'&&curPoints.length>=2){
    // 消しゴム：ストロークのパスを直接削除する方式
    applyEraserToStrokes(fr,curPoints,S.penSize*3);
  }
  else if(S.tool==='line'&&shapeStart){
    const newStroke = {type:'line',x1:shapeStart.x,y1:shapeStart.y,x2:p.x,y2:p.y,color:S.penColor,size:S.penSize,order:fr.strokes.length};
    if(snapEnabled){
      // すべてのレイヤーのストロークを収集
      const allStrokes = [];
      CF().forEach(layer => {
        if(layer.frames[S.frame] && layer.frames[S.frame].strokes){
          allStrokes.push(...layer.frames[S.frame].strokes);
        }
      });
      const snapped = snapNewStrokeToExisting(newStroke, allStrokes, 10, snapFullStroke);
      fr.strokes.push(snapped);
    } else {
      fr.strokes.push(newStroke);
    }
  }
  else if(S.tool==='circle'&&shapeStart){
    const newStroke = {type:'ellipse',cx:(shapeStart.x+p.x)/2,cy:(shapeStart.y+p.y)/2,rx:Math.abs(p.x-shapeStart.x)/2,ry:Math.abs(p.y-shapeStart.y)/2,color:S.penColor,size:S.penSize,order:fr.strokes.length};
    if(snapEnabled){
      // すべてのレイヤーのストロークを収集
      const allStrokes = [];
      CF().forEach(layer => {
        if(layer.frames[S.frame] && layer.frames[S.frame].strokes){
          allStrokes.push(...layer.frames[S.frame].strokes);
        }
      });
      const snapped = snapNewStrokeToExisting(newStroke, allStrokes, 10, snapFullStroke);
      fr.strokes.push(snapped);
    } else {
      fr.strokes.push(newStroke);
    }
  }
  else if(S.tool==='rect'&&shapeStart){
    const newStroke = {type:'rect',x:Math.min(shapeStart.x,p.x),y:Math.min(shapeStart.y,p.y),w:Math.abs(p.x-shapeStart.x),h:Math.abs(p.y-shapeStart.y),color:S.penColor,size:S.penSize,order:fr.strokes.length};
    if(snapEnabled){
      // すべてのレイヤーのストロークを収集
      const allStrokes = [];
      CF().forEach(layer => {
        if(layer.frames[S.frame] && layer.frames[S.frame].strokes){
          allStrokes.push(...layer.frames[S.frame].strokes);
        }
      });
      const snapped = snapNewStrokeToExisting(newStroke, allStrokes, 10, snapFullStroke);
      fr.strokes.push(snapped);
    } else {
      fr.strokes.push(newStroke);
    }
  }
  curPoints=[];shapeStart=null;drawingSnapshot=null;renderAll();updateTimeline();
}
function onWheel(e){e.preventDefault();const a=document.getElementById('canvas-area').getBoundingClientRect();const mx=e.clientX-a.left,my=e.clientY-a.top;const old=S.zoom;S.zoom=Math.max(0.1,Math.min(10,S.zoom*(e.deltaY>0?0.9:1.1)));S.panX=mx-(mx-S.panX)*(S.zoom/old);S.panY=my-(my-S.panY)*(S.zoom/old);updateTransform();}
function onKeyDown(e){
  if(e.code==='Space'){spaceHeld=true;e.preventDefault();}
  if(e.ctrlKey||e.metaKey)ctrlHeld=true;
  if((e.ctrlKey||e.metaKey)&&e.key==='z'&&!e.shiftKey){e.preventDefault();undoAction();}
  if((e.ctrlKey||e.metaKey)&&(e.key==='y'||(e.key==='z'&&e.shiftKey))){e.preventDefault();redoAction();}
  if((e.ctrlKey||e.metaKey)&&e.key==='s'){e.preventDefault();saveProject();}
  if((e.ctrlKey||e.metaKey)&&e.key==='c'&&!e.shiftKey){ctxLayer=S.layer;ctxFrame=S.frame;ctxCopyFrame();}
  if((e.ctrlKey||e.metaKey)&&e.key==='v'&&!e.shiftKey){ctxLayer=S.layer;ctxFrame=S.frame;ctxPasteFrame();}
  if(!e.ctrlKey&&!e.metaKey){if(e.key==='p')selectTool('pen');if(e.key==='l')selectTool('line');if(e.key==='c')selectTool('circle');if(e.key==='r')selectTool('rect');if(e.key==='e')selectTool('eraser');if(e.key==='a')selectTool('point');if(e.key==='s')selectTool('stroke');if(e.key==='v')selectTool('move');}
  
  // onKeyDown 関数の中
if (e.code === 'Numpad2') {
  e.preventDefault();
  const sizeInput = document.getElementById('pen-size');   // ← brush-size → pen-size に修正
  if (sizeInput) {
    let current = parseInt(sizeInput.value, 10) || S.penSize;
    if (current > 1) {
      current--;
      sizeInput.value = current;
      S.penSize = current;
      document.getElementById('pen-size-val').textContent = current; // 表示も更新
      notify(`ブラシサイズ: ${current}px`);
    }
  }
}

if (e.code === 'Numpad8') {
  e.preventDefault();
  const sizeInput = document.getElementById('pen-size');   // ← ここも修正
  if (sizeInput) {
    let current = parseInt(sizeInput.value, 10) || S.penSize;
    if (current < 50) {
      current++;
      sizeInput.value = current;
      S.penSize = current;
      document.getElementById('pen-size-val').textContent = current;
      notify(`ブラシサイズ: ${current}px`);
    }
  }
}
  
  // 書き順フィルターの矢印キー操作（書き順ガイド表示時のみ）
  if(document.getElementById('stroke-guide-enabled').checked){
    const filterInput = document.getElementById('stroke-order-filter');
  // ↑キー：デフォルト→1、または現在値+1
  if(e.key === 'ArrowUp' && filterInput){
    e.preventDefault();
    
    // ★修正：前のフレームから最大orderを計算
    let maxOrder = 1;
    if(S.frame > 0){
      const prevFrame = CF()[S.layer].frames[S.frame - 1];
      if(prevFrame && prevFrame.strokes && prevFrame.strokes.length > 0){
        maxOrder = Math.max(...prevFrame.strokes.filter(s => s.type !== 'eraser').map(s => (s.order || 0) + 1));
      }
    }
    
    console.log('maxOrder (前フレーム):', maxOrder);
    
    // 現在の入力値を数値として取得
    const currentValue = filterInput.value === '' ? null : parseInt(filterInput.value, 10);
    
    console.log('currentValue:', currentValue);
    
    if(currentValue === null || isNaN(currentValue)){
      strokeOrderFilter = 1;
    } else if(currentValue < maxOrder){
      strokeOrderFilter = currentValue + 1;
    } else {
      strokeOrderFilter = currentValue; // 最大値を超えない
    }
    
    console.log('new strokeOrderFilter:', strokeOrderFilter);
    
    filterInput.value = strokeOrderFilter;
    renderAll();
    return;
  }
  // ↓キー：現在値-1、1→デフォルト
  if(e.key === 'ArrowDown' && filterInput){
    e.preventDefault();
    
    const currentValue = filterInput.value === '' ? null : parseInt(filterInput.value, 10);
    
    if(currentValue === null || isNaN(currentValue)){
      return;
    } else if(currentValue === 1){
      strokeOrderFilter = null;
      filterInput.value = '';
    } else if(currentValue > 1){
      strokeOrderFilter = currentValue - 1;
      filterInput.value = strokeOrderFilter;
    }
    renderAll();
    return;
  }

}
  
  // 通常の矢印キー（書き順ガイド無効時のみ実行される）
  if(e.key==='ArrowRight')goNextFrame();
  if(e.key==='ArrowLeft')goPrevFrame();
  
  if(e.key==='Escape'){S.rot=0;updateTransform();}
  // Delete/Backspaceでストローク削除（ストローク編集ツール時）
  if((e.key==='Delete'||e.key==='Backspace')&&S.tool==='stroke'&&strokeEditIdx>=0){
    e.preventDefault();const fr=CF()[S.layer].frames[S.frame];
    if(fr&&strokeEditIdx<fr.strokes.length){pushUndo();fr.strokes.splice(strokeEditIdx,1);strokeEditIdx=-1;strokeEditCorners=null;strokeEditCenter=null;renderAll();updateTimeline();notify('ストロークを削除');}
  }
  // Delete/Backspaceでタイムライン選択セルを一括クリア
  if((e.key==='Delete'||e.key==='Backspace')&&tlSelected.size>0&&S.tool!=='stroke'){
    e.preventDefault();pushUndo();
    for(const k of tlSelected){
      const p=k.split('-');const li=+p[0],fi=+p[1];
      CF()[li].frames[fi]={strokes:[],draftImg:null};
      delete CFD()[li+'-'+fi];
    }
    tlSelected.clear();renderAll();updateTimeline();notify('選択フレームをクリア');
  }
  // Escで選択解除
  if(e.key==='Escape'&&tlSelected.size>0){tlSelected.clear();updateTimeline();}
  // テンキーでのキャンバス回転
  if (e.code === 'NumpadSubtract' || e.code === 'Minus') {
    e.preventDefault();
    S.rot -= 3;
    updateTransform();
    document.getElementById('rotation-indicator').textContent = Math.round(S.rot) + '°';
    document.getElementById('rotation-indicator').style.display = 'block';
    clearTimeout(window._rotHideTimer);
    window._rotHideTimer = setTimeout(() => {
      document.getElementById('rotation-indicator').style.display = 'none';
    }, 1200);
  }
  else if (e.code === 'NumpadAdd' || e.code === 'Equal') {
    e.preventDefault();
    S.rot += 3;
    updateTransform();
    document.getElementById('rotation-indicator').textContent = Math.round(S.rot) + '°';
    document.getElementById('rotation-indicator').style.display = 'block';
    clearTimeout(window._rotHideTimer);
    window._rotHideTimer = setTimeout(() => {
      document.getElementById('rotation-indicator').style.display = 'none';
    }, 1200);
  }
}
function onKeyUp(e){if(e.code==='Space')spaceHeld=false;if(!e.ctrlKey&&!e.metaKey)ctrlHeld=false;}

// ★ ストローク吸着の有効/無効を切り替え
function toggleSnapEnabled() {
  snapEnabled = document.getElementById('snap-enabled-checkbox').checked;
  
  // 全体吸着チェックボックスの表示/非表示を制御
  const fullLabel = document.getElementById('snap-full-stroke-label');
  if (fullLabel) {
    fullLabel.style.display = snapEnabled ? 'flex' : 'none';
  }
  
  // 自動中割ダイアログのチェックボックスも同期
  const inbSnap = document.getElementById('inb-snap-enabled');
  if (inbSnap) inbSnap.checked = snapEnabled;

  const inbFull = document.getElementById('inb-snap-full-stroke-checkbox');
  if (inbFull) {
    inbFull.checked = snapFullStroke;
    inbFull.disabled = !snapEnabled;
  }
}
function toggleSnapFullStroke() {
  snapFullStroke = document.getElementById('snap-full-stroke-checkbox').checked;
  
  // 自動中割ダイアログ側も同期（存在する場合）
  const inbFull = document.getElementById('inb-snap-full-stroke-checkbox');
  if (inbFull) {
    inbFull.checked = snapFullStroke;
  }
  
  notify(snapFullStroke ? 'ストローク全体吸着 ON' : 'ストローク全体吸着 OFF');
}

// ★ 自動中割ダイアログからの逆同期
function syncSnapFromInbetween(){
  snapEnabled = document.getElementById('inb-snap-enabled').checked;
  // ツールパネルのチェックボックスも同期
  const snapCheckbox = document.getElementById('snap-enabled-checkbox');
  if(snapCheckbox) snapCheckbox.checked = snapEnabled;
}

function selectTool(t){
  console.log('selectTool called with:', t); // デバッグ用
  if(!t) {
    console.error('Tool is undefined or null');
    return;
  }
  S.tool=t;
  document.querySelectorAll('.tool-btn[data-tool]').forEach(b=>{
    const isActive = b.dataset.tool===t;
    b.classList.toggle('active', isActive);
  });
  // ツール切替時にポイント編集状態クリア
  if(t!=='point'){selectedStrokeIdx=-1;dragPointInfo=null;selectedPointInfo=null;}
  if(t!=='stroke'){strokeEditIdx=-1;strokeEditMode='';strokeEditCorners=null;strokeEditCenter=null;strokeEditAnchor=null;}
  if(t!=='move'){moveDragging=false;moveTargetIdx=-1;}
  // ツールバー下部パネル切替
  document.getElementById('pen-settings').style.display=(t==='pen'||t==='line'||t==='circle'||t==='rect'||t==='eraser')?'':'none';
  document.getElementById('stroke-point-settings').style.display=(t==='stroke'||t==='point')?'':'none';
  updateStrokePointSlider();
  renderAll();
  // カーソル変更
  const area=document.getElementById('canvas-area');
  const cp=document.getElementById('cursor-preview');
  if(t==='point'||t==='stroke'){area.style.cursor='default';cp.style.display='none';}
  else if(t==='move'){area.style.cursor='move';cp.style.display='none';}
  else{area.style.cursor='crosshair';cp.style.display='';}
  updateActiveColorButton(); // カラーパレット更新
  console.log('Tool changed to:', S.tool); // デバッグ用
}

// ===========================================================
// コンテキストメニュー（タイムライン右クリック）
// ===========================================================
function showCtxMenu(e,li,fi){
  e.preventDefault();e.stopPropagation();
  ctxLayer=li;ctxFrame=fi;
  const m=document.getElementById('ctx-menu');
  document.getElementById('ctx-paste').classList.toggle('disabled',!clipFrame);
  document.getElementById('ctx-paste-all').classList.toggle('disabled',!clipAllFrames);
  m.style.display='block';m.style.left=e.clientX+'px';m.style.top=e.clientY+'px';
  // メニューが画面外に出ないよう調整
  const rect=m.getBoundingClientRect();
  if(rect.right>window.innerWidth)m.style.left=(e.clientX-rect.width)+'px';
  if(rect.bottom>window.innerHeight)m.style.top=(e.clientY-rect.height)+'px';
}
function hideCtxMenu(){document.getElementById('ctx-menu').style.display='none';}

function ctxCopyFrame(){
  const fr=CF()[ctxLayer].frames[ctxFrame];
  clipFrame=JSON.parse(JSON.stringify(fr));
  hideCtxMenu();notify(`レイヤー${ctxLayer+1} フレーム${ctxFrame+1} をコピー`);
}
function ctxPasteFrame(){
  if(!clipFrame){notify('コピーされたフレームがありません');hideCtxMenu();return;}
  pushUndo();
  CF()[ctxLayer].frames[ctxFrame]=JSON.parse(JSON.stringify(clipFrame));
  hideCtxMenu();renderAll();updateTimeline();notify(`フレーム${ctxFrame+1} に貼り付け`);
}
function ctxCopyAllLayers(){
  clipAllFrames=[];
  for(let li=0;li<LAYER_DEFS.length;li++){clipAllFrames.push(JSON.parse(JSON.stringify(CF()[li].frames[ctxFrame])));}
  hideCtxMenu();notify(`全レイヤー フレーム${ctxFrame+1} をコピー`);
}
function ctxPasteAllLayers(){
  if(!clipAllFrames){notify('コピーされたフレームがありません');hideCtxMenu();return;}
  pushUndo();
  for(let li=0;li<LAYER_DEFS.length;li++){if(clipAllFrames[li])CF()[li].frames[ctxFrame]=JSON.parse(JSON.stringify(clipAllFrames[li]));}
  hideCtxMenu();renderAll();updateTimeline();notify(`全レイヤー フレーム${ctxFrame+1} に貼り付け`);
}
function ctxClearFrame(){
  pushUndo();
  CF()[ctxLayer].frames[ctxFrame]={strokes:[],draftImg:null};
  hideCtxMenu();renderAll();updateTimeline();notify(`フレーム${ctxFrame+1} をクリア`);
}
function ctxInsertFrame(){
  pushUndo();const f=ctxFrame+1;
  for(let i=0;i<LAYER_DEFS.length;i++)CF()[i].frames.splice(f,0,{strokes:[],draftImg:null});
  CC().totalFrames++;hideCtxMenu();goToFrame(f);notify('キーフレームを挿入');
}
function ctxSetDuration(){
  hideCtxMenu();
  const key = ctxLayer + '-' + ctxFrame;
  
  // モーダルに選択数情報を表示する要素がない場合は追加
  let infoDiv = document.getElementById('dur-modal-info');
  if(!infoDiv){
    const modalBox = document.querySelector('#duration-modal .modal-box');
    const h3 = modalBox.querySelector('h3');
    infoDiv = document.createElement('div');
    infoDiv.id = 'dur-modal-info';
    infoDiv.style.cssText = 'font-size:11px;color:var(--text-muted);margin-bottom:8px;';
    h3.after(infoDiv);
  }
  
  // 複数フレーム選択されているか確認
  if(tlSelected.size > 0 && tlSelected.has(key)){
    // 複数選択の場合
    document.getElementById('dur-modal-input').value = CFD()[key] || 1;
    infoDiv.textContent = `選択中の${tlSelected.size}フレームに一括適用されます`;
  } else {
    // 単一フレームの場合
    document.getElementById('dur-modal-input').value = CFD()[key] || 1;
    infoDiv.textContent = '';
  }
  
  document.getElementById('duration-modal').classList.add('show');
}
function applyDurModal(){
  const v=+document.getElementById('dur-modal-input').value;
  if(v<1) return;
  
  pushUndo();
  
  console.log('[applyDurModal] tlSelected:', tlSelected);
  console.log('[applyDurModal] tlSelected.size:', tlSelected.size);
  
  // 複数フレーム選択されている場合
  if(tlSelected.size > 0){
    const key = ctxLayer + '-' + ctxFrame;
    console.log('[applyDurModal] key:', key);
    console.log('[applyDurModal] tlSelected.has(key):', tlSelected.has(key));
    
    // 右クリックしたフレームが選択に含まれている場合のみ一括適用
    if(tlSelected.has(key)){
      console.log('[applyDurModal] 複数選択モード - 選択フレーム一覧:');
      
      // まず持続時間を全て設定
      for(const k of tlSelected){
        console.log('  設定: ' + k + ' → ' + v + 'f');
        CFD()[k] = v;
      }
      
      console.log('[applyDurModal] CFD():', CFD());
      
      // 各レイヤーごとにフレーム配列を再構築
      const processedLayers = new Set();
      for(const k of tlSelected){
        const [li] = k.split('-').map(Number);
        if(!processedLayers.has(li)){
          processedLayers.add(li);
          console.log('[applyDurModal] レイヤー' + li + 'を再構築');
          rebuildFramesForLayer(li);
        }
      }
      
      closeModal('duration-modal');
      updateTimeline();
      notify(`選択中の${tlSelected.size}フレームの持続時間を ${v}f に設定`);
      return;
    }
  }
  
  // 単一フレームの場合
  console.log('[applyDurModal] 単一フレームモード');
  CFD()[ctxLayer + '-' + ctxFrame] = v;
  rebuildFramesForLayer(ctxLayer);
  
  closeModal('duration-modal');
  updateTimeline();
  notify(`フレーム${ctxFrame+1} → ${v}f持続`);
}

// レイヤーのフレーム配列を持続設定に基づいて再構築
function rebuildFramesForLayer(li){
  const frames = CF()[li].frames;
  const dur = CFD();
  const newFrames = [];
  
  console.log('[rebuildFramesForLayer] レイヤー' + li + '処理開始');
  console.log('[rebuildFramesForLayer] 元のフレーム数:', frames.length);
  
  // 元のフレームデータを保持しているフレームを探す
  const keyFrames = [];
  for(let fi = 0; fi < frames.length; fi++){
    const fr = frames[fi];
    if(fr && (fr.strokes.length > 0 || fr.draftImg)){
      const duration = dur[li + '-' + fi] || 1;
      keyFrames.push({index: fi, frame: fr, duration: duration});
      console.log('[rebuildFramesForLayer] キーフレーム検出: index=' + fi + ', duration=' + duration);
    }
  }
  
  console.log('[rebuildFramesForLayer] キーフレーム総数:', keyFrames.length);
  
  // 持続設定に基づいて新しいフレーム配列を構築
  for(const kf of keyFrames){
    // キーフレームを追加
    newFrames.push(kf.frame);
    
    // 持続フレーム分の空フレームを追加
    for(let i = 1; i < kf.duration; i++){
      newFrames.push({strokes:[], draftImg:null});
    }
  }
  
  console.log('[rebuildFramesForLayer] 新しいフレーム数:', newFrames.length);
  
  // フレーム配列を置き換え
  CF()[li].frames = newFrames;
  
  // 持続設定のインデックスを更新
  let currentIndex = 0;
  for(const kf of keyFrames){
    const oldKey = li + '-' + kf.index;
    const newKey = li + '-' + currentIndex;
    
    if(oldKey !== newKey){
      if(dur[oldKey]){
        dur[newKey] = dur[oldKey];
        delete dur[oldKey];
        console.log('[rebuildFramesForLayer] 持続設定移動: ' + oldKey + ' → ' + newKey);
      }
    }
    
    currentIndex += kf.duration;
  }
  
  // 総フレーム数を更新
  CC().totalFrames = Math.max(CC().totalFrames, newFrames.length);
  console.log('[rebuildFramesForLayer] 総フレーム数更新:', CC().totalFrames);
}

// ===========================================================
// スムージング & ベジェ
// ===========================================================
function smoothPoints(pts){
  if(pts.length<3)return pts;
  const totalLen=pathLength(pts);if(totalLen<2)return pts;
  const sv=S.penSmooth/100; // 0.0〜1.0
  // sv=0: 補正なし（間引きのみ最小限）
  if(sv===0){
    // 距離ベースで最低限リサンプル（1px間隔をまとめる程度）
    const re=resamplePath(pts,Math.max(3,Math.floor(totalLen/1.5)));
    return rdp(re,0.3);
  }
  // リサンプル間隔: sv=0→1.5px, sv=1→6px
  const spacing=1.5+sv*4.5;
  const numSamples=Math.max(3,Math.floor(totalLen/spacing));
  const re=resamplePath(pts,numSamples);
  // スムージング強度: sv=0→0, sv=1→0.35（前後の重み）
  const w=sv*0.35;
  const r=[re[0]];
  for(let i=1;i<re.length-1;i++){
    const p=re[i-1],c=re[i],n=re[i+1];
    r.push({x:p.x*w+c.x*(1-2*w)+n.x*w,y:p.y*w+c.y*(1-2*w)+n.y*w});
  }
  r.push(re[re.length-1]);
  // RDP閾値: sv=0→0.3, sv=1→1.5
  const rdpEp=0.3+sv*1.2;
  return rdp(r,rdpEp);
}
function pathLength(pts){let l=0;for(let i=1;i<pts.length;i++)l+=Math.hypot(pts[i].x-pts[i-1].x,pts[i].y-pts[i-1].y);return l;}
function resamplePath(pts,n){
  const tl=pathLength(pts);if(tl===0||n<2)return[pts[0],pts[pts.length-1]];
  const step=tl/(n-1);const r=[pts[0]];let idx=0,carry=0;
  for(let i=1;i<n-1;i++){let target=step*i;while(idx<pts.length-1){const sl=Math.hypot(pts[idx+1].x-pts[idx].x,pts[idx+1].y-pts[idx].y);if(carry+sl>=target){const t=(target-carry)/sl;r.push({x:pts[idx].x+(pts[idx+1].x-pts[idx].x)*t,y:pts[idx].y+(pts[idx+1].y-pts[idx].y)*t});break;}carry+=sl;idx++;}}
  r.push(pts[pts.length-1]);return r;
}
function rdp(pts,ep){if(pts.length<=2)return pts;let mx=0,mi=0;const f=pts[0],l=pts[pts.length-1];for(let i=1;i<pts.length-1;i++){const d=ptLineDist(pts[i],f,l);if(d>mx){mx=d;mi=i;}}if(mx>ep){const a=rdp(pts.slice(0,mi+1),ep);const b=rdp(pts.slice(mi),ep);return a.slice(0,-1).concat(b);}return[f,l];}
function ptLineDist(p,a,b){const dx=b.x-a.x,dy=b.y-a.y,ls=dx*dx+dy*dy;if(ls===0)return Math.hypot(p.x-a.x,p.y-a.y);let t=((p.x-a.x)*dx+(p.y-a.y)*dy)/ls;t=Math.max(0,Math.min(1,t));return Math.hypot(p.x-(a.x+t*dx),p.y-(a.y+t*dy));}
function toBezier(pts){
  if(pts.length<2)return[];if(pts.length===2)return[{sx:pts[0].x,sy:pts[0].y,cx:(pts[0].x+pts[1].x)/2,cy:(pts[0].y+pts[1].y)/2,ex:pts[1].x,ey:pts[1].y}];
  const c=[];c.push({sx:pts[0].x,sy:pts[0].y,cx:pts[0].x,cy:pts[0].y,ex:(pts[0].x+pts[1].x)/2,ey:(pts[0].y+pts[1].y)/2});
  for(let i=1;i<pts.length-1;i++)c.push({sx:(pts[i-1].x+pts[i].x)/2,sy:(pts[i-1].y+pts[i].y)/2,cx:pts[i].x,cy:pts[i].y,ex:(pts[i].x+pts[i+1].x)/2,ey:(pts[i].y+pts[i+1].y)/2});
  const n=pts.length-1;c.push({sx:(pts[n-1].x+pts[n].x)/2,sy:(pts[n-1].y+pts[n].y)/2,cx:pts[n].x,cy:pts[n].y,ex:pts[n].x,ey:pts[n].y});return c;
}

// ===========================================================
// 消しゴム：ストロークのパスを直接削除する方式
// ===========================================================
function applyEraserToStrokes(fr,eraserPts,eraserSize){
  if(eraserPts.length<2)return;
  // 消しゴムパスをサンプリング（粗め）
  const ePts=[];
  const step=Math.max(eraserSize/2,4);
  for(let i=0;i<eraserPts.length;i++){
    ePts.push(eraserPts[i]);
    if(i<eraserPts.length-1){
      const a=eraserPts[i],b=eraserPts[i+1];
      const dx=b.x-a.x,dy=b.y-a.y;
      const d=Math.sqrt(dx*dx+dy*dy);
      if(d>step){
        const n=Math.ceil(d/step);
        for(let j=1;j<n;j++)ePts.push({x:a.x+dx*j/n,y:a.y+dy*j/n});
      }
    }
  }
  const r=eraserSize/2;
  // グリッド空間インデックス構築
  const cellSize=r*2||20;
  const grid={};
  for(const ep of ePts){
    const gx=Math.floor(ep.x/cellSize),gy=Math.floor(ep.y/cellSize);
    for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){
      const key=(gx+dx)+','+(gy+dy);
      if(!grid[key])grid[key]=[];
      grid[key].push(ep);
    }
  }
  const newStrokes=[];
  for(const s of fr.strokes){
    if(s.type==='eraser')continue;
    if(s.type==='bezier'&&s.controls&&s.controls.length>0){
      // まず消しゴムがこのストロークに実際に触れているかチェック
      const hitResult=checkBezierHit(s.controls,grid,cellSize,r,s.size);
      if(!hitResult.anyHit){
        // 消しゴムが触れていない→そのまま保持
        newStrokes.push({...s,order:newStrokes.length});
      }else{
        // 消しゴムが触れている→分割処理
        const surviving=eraseBezierSegments(s.controls,grid,cellSize,r,s.size);
        for(const seg of surviving){
          if(seg.length>0)newStrokes.push({type:'bezier',controls:seg,color:s.color,size:s.size,order:newStrokes.length});
        }
      }
    }else if(s.type==='line'){
      // まず消しゴムが触れているかチェック
      const pts=sampleLine(s.x1,s.y1,s.x2,s.y2,r);
      const hitR=r+s.size/2;const hitR2=hitR*hitR;
      let anyHit=false;
      for(const p of pts){
        const gx=Math.floor(p.x/cellSize),gy=Math.floor(p.y/cellSize);
        const eps=grid[gx+','+gy];
        if(!eps)continue;
        for(const ep of eps){const dx2=p.x-ep.x,dy2=p.y-ep.y;if(dx2*dx2+dy2*dy2<hitR2){anyHit=true;break;}}
        if(anyHit)break;
      }
      if(!anyHit){
        newStrokes.push({...s,order:newStrokes.length});
      }else{
        const surviving=erasePointSequence(pts,grid,cellSize,r,s.size);
        for(const seg of surviving){
          if(seg.length>=2)newStrokes.push({type:'line',x1:seg[0].x,y1:seg[0].y,x2:seg[seg.length-1].x,y2:seg[seg.length-1].y,color:s.color,size:s.size,order:newStrokes.length});
        }
      }
    }else if(s.type==='ellipse'){
      const hit=isHitGrid(grid,cellSize,s.cx,s.cy,Math.max(s.rx,s.ry)+r);
      if(!hit)newStrokes.push({...s,order:newStrokes.length});
    }else if(s.type==='rect'){
      const cx=s.x+s.w/2,cy=s.y+s.h/2;
      const hit=isHitGrid(grid,cellSize,cx,cy,Math.hypot(s.w,s.h)/2+r);
      if(!hit)newStrokes.push({...s,order:newStrokes.length});
    }else{
      newStrokes.push({...s,order:newStrokes.length});
    }
  }
  fr.strokes=newStrokes;
}
// 消しゴムがベジェストロークに触れているかだけチェック（再構築はしない）
function checkBezierHit(controls,grid,cellSize,r,strokeSize){
  const hitR=r+strokeSize/2;
  const hitR2=hitR*hitR;
  for(let i=0;i<controls.length;i++){
    const c=controls[i];
    const steps=6;
    for(let t=0;t<=steps;t++){
      if(i>0&&t===0)continue;
      const tt=t/steps,u=1-tt;
      const px=u*u*c.sx+2*u*tt*c.cx+tt*tt*c.ex;
      const py=u*u*c.sy+2*u*tt*c.cy+tt*tt*c.ey;
      const gx=Math.floor(px/cellSize),gy=Math.floor(py/cellSize);
      const pts=grid[gx+','+gy];
      if(!pts)continue;
      for(const ep of pts){
        const dx=px-ep.x,dy=py-ep.y;
        if(dx*dx+dy*dy<hitR2)return{anyHit:true};
      }
    }
  }
  return{anyHit:false};
}
function isHitGrid(grid,cellSize,x,y,radius){
  const gx=Math.floor(x/cellSize),gy=Math.floor(y/cellSize);
  const key=gx+','+gy;
  const pts=grid[key];
  if(!pts)return false;
  const r2=radius*radius;
  for(const ep of pts){const dx=x-ep.x,dy=y-ep.y;if(dx*dx+dy*dy<r2)return true;}
  return false;
}

function eraseBezierSegments(controls,grid,cellSize,r,strokeSize){
  const allPts=[];
  // セグメントインデックスも記録（どの制御点由来か）
  const segIdx=[];
  for(let i=0;i<controls.length;i++){
    const c=controls[i];
    const steps=10;// サンプリング精度向上
    for(let t=0;t<=steps;t++){
      if(i>0&&t===0)continue;
      const tt=t/steps,u=1-tt;
      allPts.push({x:u*u*c.sx+2*u*tt*c.cx+tt*tt*c.ex,y:u*u*c.sy+2*u*tt*c.cy+tt*tt*c.ey});
      segIdx.push(i);
    }
  }
  const hitR=r+strokeSize/2;
  const hitR2=hitR*hitR;
  const erased=new Uint8Array(allPts.length);
  for(let i=0;i<allPts.length;i++){
    const p=allPts[i];
    const gx=Math.floor(p.x/cellSize),gy=Math.floor(p.y/cellSize);
    const pts=grid[gx+','+gy];
    if(!pts)continue;
    for(const ep of pts){
      const dx=p.x-ep.x,dy=p.y-ep.y;
      if(dx*dx+dy*dy<hitR2){erased[i]=1;break;}
    }
  }
  const segments=[];
  let start=-1;
  for(let i=0;i<=allPts.length;i++){
    if(i<allPts.length&&!erased[i]){
      if(start===-1)start=i;
    }else{
      if(start!==-1){
        let pts=allPts.slice(start,i).map(p=>({x:p.x,y:p.y}));
        if(pts.length>=2){
          // 生存セグメントに関連する元の制御点数を元に上限を決める
          const startSeg=segIdx[start]||0;
          const endSeg=segIdx[Math.min(i-1,segIdx.length-1)]||0;
          const origCount=endSeg-startSeg+1;
          const maxPts=Math.max(origCount*2,8);// より緩い制限
          if(pts.length>maxPts){
            pts=rdp(pts,0.3);// より小さいepsilonで精度維持
            if(pts.length>maxPts)pts=resamplePath(pts,maxPts);
          }
          segments.push(toBezier(pts));
        }
        start=-1;
      }
    }
  }
  return segments;
}

function sampleLine(x1,y1,x2,y2,r){
  const dx=x2-x1,dy=y2-y1;
  const d=Math.sqrt(dx*dx+dy*dy);
  const step=r/2;
  const n=Math.max(2,Math.ceil(d/step));
  const pts=[];
  for(let i=0;i<=n;i++){
    pts.push({x:x1+dx*i/n,y:y1+dy*i/n});
  }
  return pts;
}

function erasePointSequence(pts,grid,cellSize,r,strokeSize){
  const hitR=r+strokeSize/2;
  const hitR2=hitR*hitR;
  const erased=new Uint8Array(pts.length);
  for(let i=0;i<pts.length;i++){
    const p=pts[i];
    const gx=Math.floor(p.x/cellSize),gy=Math.floor(p.y/cellSize);
    const eps=grid[gx+','+gy];
    if(!eps)continue;
    for(const ep of eps){
      const dx=p.x-ep.x,dy=p.y-ep.y;
      if(dx*dx+dy*dy<hitR2){erased[i]=1;break;}
    }
  }
  const segments=[];
  let start=-1;
  for(let i=0;i<=pts.length;i++){
    if(i<pts.length&&!erased[i]){
      if(start===-1)start=i;
    }else{
      if(start!==-1){segments.push(pts.slice(start,i));start=-1;}
    }
  }
  return segments;
}

// ===========================================================
// 描画
// ===========================================================
function renderAll(){
  for(let i = LAYER_DEFS.length - 1; i >= 0; i--){
    renderLayer(i, S.frame);
    layerCanvases[i].style.display = layerVis[i] ? 'block' : 'none';
  }
  renderOnion();           // オニオンも逆順にする
  renderStrokeGuide();
  renderPointEditOverlay();
  renderStrokeEditOverlay();
  updateStrokePointSlider();
  updateFrameGuide();
  // レイヤー・ストローク情報の更新
updateLayerStrokeInfo();
}
// レイヤー・ストローク情報を更新
function updateLayerStrokeInfo() {
  const fr = CF()[S.layer].frames[S.frame];

  // 現在選択中のフレームのストローク数（eraser除く）
  const strokeCount = fr && fr.strokes
    ? fr.strokes.filter(s => s.type !== 'eraser').length
    : 0;

  // レイヤー名
  document.getElementById('current-layer-name').textContent = 
    LAYER_DEFS[S.layer].name;

  // ストローク数（選択中フレームの数）
  document.getElementById('stroke-count').textContent = strokeCount;

  // ストローク情報
  let selectedNum = '-';
  let latestNum   = '-';

  if (fr && strokeCount > 0) {
    const validStrokes = fr.strokes.filter(s => s.type !== 'eraser');

    // 最新の書き順番号（order最大 +1）
    if (validStrokes.length > 0) {
      const maxOrder = Math.max(...validStrokes.map(s => s.order || 0));
      latestNum = (maxOrder + 1).toString();
    }

    // 選択中の書き順番号
    let selIdx = -1;
    if (S.tool === 'stroke' && strokeEditIdx >= 0) {
      selIdx = strokeEditIdx;
    } else if (S.tool === 'point' && selectedStrokeIdx >= 0) {
      selIdx = selectedStrokeIdx;
    }

    if (selIdx >= 0 && selIdx < fr.strokes.length) {
      const s = fr.strokes[selIdx];
      if (s && s.type !== 'eraser') {
        selectedNum = ((s.order || 0) + 1).toString();
      }
    }
  }

  document.getElementById('selected-stroke-num').textContent = selectedNum;
  document.getElementById('latest-stroke-num').textContent   = latestNum;
}

function updateFrameGuide(){
  const el=document.getElementById('frame-guide-overlay');
  const enabled=document.getElementById('frame-guide-enabled').checked;
  if(!enabled){el.style.display='none';return;}
  frameGuideW=+document.getElementById('frame-guide-w').value||1920;
  frameGuideH=+document.getElementById('frame-guide-h').value||1080;
  const left=(S.cw-frameGuideW)/2;
  const top=(S.ch-frameGuideH)/2;
  el.style.display='block';
  el.style.left=left+'px';el.style.top=top+'px';
  el.style.width=frameGuideW+'px';el.style.height=frameGuideH+'px';
}
function renderLayer(li,fi){
  const ctx=layerCtxs[li];
  const isDraft=LAYER_DEFS[li].type==='draft';
  // 下書きレイヤーはCSS opacityで全描画（画像+ストローク）に不透明度適用
  layerCanvases[li].style.opacity=isDraft?draftOpacity:1;

  if(fi<0||fi>=CF()[li].frames.length){ctx.clearRect(0,0,S.cw,S.ch);return;}
  const fr=getEffectiveFrame(li,fi);
  if(!fr){ctx.clearRect(0,0,S.cw,S.ch);return;}

  if(fr.draftImg){
    const eidx=getEffectiveFrameIdx(li,fi);
    const key=currentCut+'-'+li+'-'+eidx;
    const drawWithImg=(img)=>{
      ctx.clearRect(0,0,S.cw,S.ch);
      ctx.drawImage(img,0,0,S.cw,S.ch);
      drawStrokes(ctx,fr.strokes);if(!isDraft)binarizeCanvas(ctx,S.cw,S.ch);
    };
    if(draftImgCache[key]&&draftImgCache[key].src===fr.draftImg){
      drawWithImg(draftImgCache[key]);
    }else{
      const img=new Image();img.onload=()=>{
        draftImgCache[key]=img;drawWithImg(img);
      };img.src=fr.draftImg;
    }
    return;
  }
  ctx.clearRect(0,0,S.cw,S.ch);
  drawStrokes(ctx,fr.strokes);if(!isDraft)binarizeCanvas(ctx,S.cw,S.ch);
}
function drawStrokes(ctx,strokes){
  for(const s of strokes){
    if(s.type==='eraser')continue; // 旧データ互換：eraserストロークは無視
    drawStroke(ctx,s);
  }
}
function drawStroke(ctx,s){
  ctx.lineCap='round';ctx.lineJoin='round';
  if(s.type==='bezier'){ctx.globalCompositeOperation='source-over';ctx.strokeStyle=s.color;ctx.lineWidth=s.size;ctx.beginPath();if(s.controls.length>0){ctx.moveTo(s.controls[0].sx,s.controls[0].sy);for(const c of s.controls)ctx.quadraticCurveTo(c.cx,c.cy,c.ex,c.ey);}ctx.stroke();}
  else if(s.type==='eraser'){ctx.globalCompositeOperation='destination-out';ctx.strokeStyle='#fff';ctx.lineWidth=s.size;ctx.beginPath();if(s.controls&&s.controls.length>0){ctx.moveTo(s.controls[0].sx,s.controls[0].sy);for(const c of s.controls)ctx.quadraticCurveTo(c.cx,c.cy,c.ex,c.ey);}ctx.stroke();ctx.globalCompositeOperation='source-over';}
  else if(s.type==='line'){ctx.globalCompositeOperation='source-over';ctx.strokeStyle=s.color;ctx.lineWidth=s.size;ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);ctx.stroke();}
  else if(s.type==='ellipse'){ctx.globalCompositeOperation='source-over';ctx.strokeStyle=s.color;ctx.lineWidth=s.size;ctx.beginPath();ctx.ellipse(s.cx,s.cy,Math.max(1,s.rx),Math.max(1,s.ry),0,0,Math.PI*2);ctx.stroke();}
  else if(s.type==='rect'){ctx.globalCompositeOperation='source-over';ctx.strokeStyle=s.color;ctx.lineWidth=s.size;ctx.beginPath();ctx.rect(s.x,s.y,s.w,s.h);ctx.stroke();}
}
// 二値化：アルファ値を閾値で0か255に変換（アンチエイリアス除去）
function binarizeCanvas(ctx,w,h){
  const imgData=ctx.getImageData(0,0,w,h);
  const d=imgData.data;
  const threshold=128;
  for(let i=3;i<d.length;i+=4){
    d[i]=d[i]>=threshold?255:0;
  }
  ctx.putImageData(imgData,0,0);
}
function renderStrokePreview(){
  const ctx=layerCtxs[S.layer];
  if(drawingSnapshot){ctx.putImageData(drawingSnapshot,0,0);}else{renderLayer(S.layer,S.frame);}
  if(curPoints.length<2)return;
  ctx.lineCap='round';ctx.lineJoin='round';
  if(S.tool==='eraser'){ctx.globalCompositeOperation='destination-out';ctx.strokeStyle='#fff';ctx.lineWidth=S.penSize*3;}
  else{ctx.globalCompositeOperation='source-over';ctx.strokeStyle=S.penColor;ctx.lineWidth=S.penSize;}
  ctx.beginPath();ctx.moveTo(curPoints[0].x,curPoints[0].y);for(let i=1;i<curPoints.length;i++)ctx.lineTo(curPoints[i].x,curPoints[i].y);ctx.stroke();ctx.globalCompositeOperation='source-over';
  const isDraft=LAYER_DEFS[S.layer].type==='draft';
  if(!isDraft)binarizeCanvas(ctx,S.cw,S.ch);
}
function renderShapePreview(p){
  const ctx=layerCtxs[S.layer];
  if(drawingSnapshot){ctx.putImageData(drawingSnapshot,0,0);}else{renderLayer(S.layer,S.frame);}
  if(!shapeStart)return;
  ctx.strokeStyle=S.penColor;ctx.lineWidth=S.penSize;ctx.lineCap='square';ctx.lineJoin='miter';
  if(S.tool==='line'){ctx.beginPath();ctx.moveTo(shapeStart.x,shapeStart.y);ctx.lineTo(p.x,p.y);ctx.stroke();}
  else if(S.tool==='circle'){ctx.beginPath();ctx.ellipse((shapeStart.x+p.x)/2,(shapeStart.y+p.y)/2,Math.max(1,Math.abs(p.x-shapeStart.x)/2),Math.max(1,Math.abs(p.y-shapeStart.y)/2),0,0,Math.PI*2);ctx.stroke();}
  else if(S.tool==='rect'){ctx.beginPath();ctx.rect(Math.min(shapeStart.x,p.x),Math.min(shapeStart.y,p.y),Math.abs(p.x-shapeStart.x),Math.abs(p.y-shapeStart.y));ctx.stroke();}
  const isDraft=LAYER_DEFS[S.layer].type==='draft';
  if(!isDraft)binarizeCanvas(ctx,S.cw,S.ch);
}

// ===========================================================
// ポイント編集ツール（クリスタ風：通過点のみ表示・移動）
// ===========================================================
// ベジェストロークの通過点（パス上の点）を取得
function getStrokePathPoints(strokes,filterIdx){
  const pts=[];
  const list=(filterIdx>=0)?[{s:strokes[filterIdx],i:filterIdx}]:strokes.map((s,i)=>({s,i}));
  for(const {s,i} of list){
    if(s.type==='bezier'||s.type==='eraser'){
      if(!s.controls||s.controls.length===0)continue;
      // 最初の始点
      pts.push({x:s.controls[0].sx,y:s.controls[0].sy,strokeIdx:i,type:'bezier',idx:0,sub:'s'});
      // 各セグメントの終点（＝次セグメントの始点でもある通過点）
      for(let ci=0;ci<s.controls.length;ci++){
        pts.push({x:s.controls[ci].ex,y:s.controls[ci].ey,strokeIdx:i,type:'bezier',idx:ci,sub:'e'});
      }
    }else if(s.type==='line'){
      pts.push({x:s.x1,y:s.y1,strokeIdx:i,type:'line',idx:0,sub:'s'});
      pts.push({x:s.x2,y:s.y2,strokeIdx:i,type:'line',idx:0,sub:'e'});
    }else if(s.type==='ellipse'){
      pts.push({x:s.cx,y:s.cy,strokeIdx:i,type:'ellipse',idx:0,sub:'center'});
      pts.push({x:s.cx+s.rx,y:s.cy,strokeIdx:i,type:'ellipse',idx:0,sub:'rx'});
      pts.push({x:s.cx,y:s.cy-s.ry,strokeIdx:i,type:'ellipse',idx:0,sub:'ry'});
    }else if(s.type==='rect'){
      pts.push({x:s.x,y:s.y,strokeIdx:i,type:'rect',idx:0,sub:'tl'});
      pts.push({x:s.x+s.w,y:s.y,strokeIdx:i,type:'rect',idx:0,sub:'tr'});
      pts.push({x:s.x+s.w,y:s.y+s.h,strokeIdx:i,type:'rect',idx:0,sub:'br'});
      pts.push({x:s.x,y:s.y+s.h,strokeIdx:i,type:'rect',idx:0,sub:'bl'});
    }
  }
  return pts;
}

function findNearestPoint(pts,p,threshold){
  let best=null,bestDist=threshold;
  for(const pt of pts){
    const d=Math.hypot(pt.x-p.x,pt.y-p.y);
    if(d<bestDist){bestDist=d;best=pt;}
  }
  return best;
}

function hitTestStroke(strokes,p,threshold){
  for(let i=strokes.length-1;i>=0;i--){
    const s=strokes[i];
    if(s.type==='bezier'||s.type==='eraser'){
      if(!s.controls)continue;
      for(const c of s.controls){
        for(let t=0;t<=1;t+=0.05){
          const bx=(1-t)*(1-t)*c.sx+2*(1-t)*t*c.cx+t*t*c.ex;
          const by=(1-t)*(1-t)*c.sy+2*(1-t)*t*c.cy+t*t*c.ey;
          if(Math.hypot(bx-p.x,by-p.y)<threshold+s.size/2)return i;
        }
      }
    }else if(s.type==='line'){
      const d=ptLineDist(p,{x:s.x1,y:s.y1},{x:s.x2,y:s.y2});
      if(d<threshold+s.size/2)return i;
    }else if(s.type==='ellipse'){
      const dx=(p.x-s.cx)/Math.max(1,s.rx),dy=(p.y-s.cy)/Math.max(1,s.ry);
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(Math.abs(dist-1)*Math.max(s.rx,s.ry)<threshold+s.size/2)return i;
    }else if(s.type==='rect'){
      const inX=p.x>=s.x-threshold&&p.x<=s.x+s.w+threshold;
      const inY=p.y>=s.y-threshold&&p.y<=s.y+s.h+threshold;
      const nearL=Math.abs(p.x-s.x)<threshold+s.size/2;
      const nearR=Math.abs(p.x-(s.x+s.w))<threshold+s.size/2;
      const nearT=Math.abs(p.y-s.y)<threshold+s.size/2;
      const nearB=Math.abs(p.y-(s.y+s.h))<threshold+s.size/2;
      if((inY&&(nearL||nearR))||(inX&&(nearT||nearB)))return i;
    }
  }
  return -1;
}

// 通過点移動：Catmull-Romで隣接制御点を自動再計算し滑らかなカーブを維持
function movePathPoint(strokes,info,nx,ny){
  const s=strokes[info.strokeIdx];
  if(info.type==='bezier'){
    const ctrls=s.controls;
    if(info.sub==='c'){
      // 制御点（ベジェハンドル）を直接ドラッグ → 直接移動＋手動調整フラグ
      ctrls[info.idx].cx=nx;ctrls[info.idx].cy=ny;
      ctrls[info.idx]._manualCP=true; // 手動調整フラグ
    }else if(info.sub==='s'&&info.idx===0){
      const dx=nx-ctrls[0].sx,dy=ny-ctrls[0].sy;
      ctrls[0].sx=nx;ctrls[0].sy=ny;
      // 隣接する制御点だけ局所更新（手動調整されていない場合のみ再計算）
      recalcLocalControlPoints(ctrls,0,dx,dy);
    }else if(info.sub==='e'){
      const ci=info.idx;
      const dx=nx-ctrls[ci].ex,dy=ny-ctrls[ci].ey;
      ctrls[ci].ex=nx;ctrls[ci].ey=ny;
      if(ci<ctrls.length-1){
        ctrls[ci+1].sx=nx;ctrls[ci+1].sy=ny;
      }
      // 影響範囲の制御点のみ局所更新
      recalcLocalControlPoints(ctrls,ci,dx,dy);
      if(ci<ctrls.length-1)recalcLocalControlPoints(ctrls,ci+1,dx,dy);
    }
  }else if(info.type==='line'){
    if(info.sub==='s'){s.x1=nx;s.y1=ny;}else{s.x2=nx;s.y2=ny;}
  }else if(info.type==='ellipse'){
    if(info.sub==='center'){s.cx=nx;s.cy=ny;}
    else if(info.sub==='rx'){s.rx=Math.max(1,Math.abs(nx-s.cx));}
    else if(info.sub==='ry'){s.ry=Math.max(1,Math.abs(ny-s.cy));}
  }else if(info.type==='rect'){
    if(info.sub==='tl'){const dx=nx-s.x,dy=ny-s.y;s.x=nx;s.y=ny;s.w-=dx;s.h-=dy;}
    else if(info.sub==='tr'){s.w=nx-s.x;const dy=ny-s.y;s.y=ny;s.h-=dy;}
    else if(info.sub==='br'){s.w=nx-s.x;s.h=ny-s.y;}
    else if(info.sub==='bl'){const dx=nx-s.x;s.x=nx;s.w-=dx;s.h=ny-s.y;}
  }
}
// 局所的な制御点再計算（通過点移動時、手動調整済みは保持）
function recalcLocalControlPoints(ctrls,segIdx,dx,dy){
  if(!ctrls||segIdx<0||segIdx>=ctrls.length)return;
  const c=ctrls[segIdx];
  if(c._manualCP){
    // 手動調整済み → 制御点を通過点の移動分だけ追従移動
    // 移動したのが始点か終点かを推定し、制御点を比例的に移動
    c.cx+=dx*0.5;c.cy+=dy*0.5;
  }else{
    // 自動計算 → Catmull-Romで再計算
    recalcSingleControlPoint(ctrls,segIdx);
  }
}
// 単一セグメントの制御点をCatmull-Romで再計算
function recalcSingleControlPoint(ctrls,segIdx){
  if(!ctrls||segIdx<0||segIdx>=ctrls.length)return;
  const pts=[{x:ctrls[0].sx,y:ctrls[0].sy}];
  for(let i=0;i<ctrls.length;i++)pts.push({x:ctrls[i].ex,y:ctrls[i].ey});
  const i=segIdx;
  const p0=pts[Math.max(0,i-1)];
  const p1=pts[i];
  const p2=pts[i+1];
  const p3=pts[Math.min(pts.length-1,i+2)];
  const cp1x=p1.x+(p2.x-p0.x)/6;
  const cp1y=p1.y+(p2.y-p0.y)/6;
  const cp2x=p2.x-(p3.x-p1.x)/6;
  const cp2y=p2.y-(p3.y-p1.y)/6;
  ctrls[i].cx=(cp1x+cp2x)/2;
  ctrls[i].cy=(cp1y+cp2y)/2;
}
// Catmull-Romで全制御点を再計算（通過点の位置から滑らかな制御点を生成）
// ※初期描画やポイント数調整時のみ使用
function recalcControlPoints(ctrls){
  if(!ctrls||ctrls.length===0)return;
  // 通過点（アンカー）を収集
  const pts=[{x:ctrls[0].sx,y:ctrls[0].sy}];
  for(let i=0;i<ctrls.length;i++)pts.push({x:ctrls[i].ex,y:ctrls[i].ey});
  // 各セグメントの制御点をCatmull-Romで計算
  for(let i=0;i<ctrls.length;i++){
    const p0=pts[Math.max(0,i-1)];
    const p1=pts[i];       // 始点
    const p2=pts[i+1];     // 終点
    const p3=pts[Math.min(pts.length-1,i+2)];
    // Catmull-Rom → cubic bezier control points
    const cp1x=p1.x+(p2.x-p0.x)/6;
    const cp1y=p1.y+(p2.y-p0.y)/6;
    const cp2x=p2.x-(p3.x-p1.x)/6;
    const cp2y=p2.y-(p3.y-p1.y)/6;
    // quadratic近似：2つのcubic制御点の中点
    ctrls[i].cx=(cp1x+cp2x)/2;
    ctrls[i].cy=(cp1y+cp2y)/2;
    delete ctrls[i]._manualCP; // フラグリセット
  }
}

function onDownPoint(p,e){
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return;
  const hitR=POINT_RADIUS/S.zoom+3;

  // 表示中のベジェハンドル（制御点）へのヒットテストを最優先
  if(selectedStrokeIdx>=0&&selectedPointInfo){
    const handlePts=getVisibleHandlePoints(fr.strokes,selectedStrokeIdx,selectedPointInfo);
    const hHit=findNearestPoint(handlePts,p,hitR);
    if(hHit){pushUndo();dragPointInfo=hHit;renderAll();return;}
  }

  // 選択中ストロークの通過点
  const selPts=selectedStrokeIdx>=0?getStrokePathPoints(fr.strokes,selectedStrokeIdx):[];
  let hit=findNearestPoint(selPts,p,hitR);
  if(!hit){
    const allPts=getStrokePathPoints(fr.strokes,-1);
    hit=findNearestPoint(allPts,p,hitR);
  }
  if(hit){
    pushUndo();dragPointInfo=hit;selectedStrokeIdx=hit.strokeIdx;
    // 通過点を選択 → ハンドル表示用に保持
    if(hit.sub!=='c')selectedPointInfo=hit;
    renderAll();return;
  }
  // ストローク本体へのヒットテスト
  const si=hitTestStroke(fr.strokes,p,8/S.zoom);
  selectedStrokeIdx=(si>=0)?si:-1;
  dragPointInfo=null;selectedPointInfo=null;
  renderAll();
}

function onMovePoint(p,e){
  if(!dragPointInfo)return;
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return;
  movePathPoint(fr.strokes,dragPointInfo,p.x,p.y);
  renderAll();
}

function onUpPoint(p,e){dragPointInfo=null;}

// 選択中ポイントの前後セグメントの制御点（ベジェハンドル）を取得
function getVisibleHandlePoints(strokes,si,activePoint){
  const pts=[];
  if(!activePoint||si<0||si>=strokes.length)return pts;
  const s=strokes[si];
  if(s.type!=='bezier'||!s.controls)return pts;
  const ctrls=s.controls;
  const added=new Set();
  const addSeg=(idx)=>{
    if(idx>=0&&idx<ctrls.length&&!added.has(idx)){
      added.add(idx);
      pts.push({x:ctrls[idx].cx,y:ctrls[idx].cy,strokeIdx:si,type:'bezier',idx,sub:'c'});
    }
  };
  if(activePoint.sub==='s'&&activePoint.idx===0){
    // 始点 → セグメント0の制御点
    addSeg(0);
  }else if(activePoint.sub==='e'){
    const ci=activePoint.idx;
    // この終点が属するセグメント
    addSeg(ci);
    // この終点＝次のセグメントの始点なので次も
    addSeg(ci+1);
  }else if(activePoint.sub==='c'){
    addSeg(activePoint.idx);
  }
  return pts;
}

// ポイント編集オーバーレイ描画
function renderPointEditOverlay(){
  pointEditCtx.clearRect(0,0,S.cw,S.ch);
  if(S.tool!=='point'&&S.tool!=='stroke'){pointEditCanvas.style.display='none';return;}
  pointEditCanvas.style.display='block';
  if(S.tool!=='point')return;
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return;
  const ctx=pointEditCtx;
  const r=POINT_RADIUS;

  // 選択ストロークのパス強調
  if(selectedStrokeIdx>=0&&selectedStrokeIdx<fr.strokes.length){
    const s=fr.strokes[selectedStrokeIdx];
    ctx.save();ctx.strokeStyle='rgba(78,205,196,0.5)';ctx.lineWidth=Math.max(s.size||2,4);ctx.lineCap='round';ctx.lineJoin='round';
    if((s.type==='bezier'||s.type==='eraser')&&s.controls&&s.controls.length>0){
      ctx.beginPath();ctx.moveTo(s.controls[0].sx,s.controls[0].sy);
      for(const c of s.controls)ctx.quadraticCurveTo(c.cx,c.cy,c.ex,c.ey);ctx.stroke();
    }
    ctx.restore();
  }

  // 選択ポイント前後のベジェハンドル描画
  const activeP=selectedPointInfo||dragPointInfo;
  if(activeP&&selectedStrokeIdx>=0&&selectedStrokeIdx<fr.strokes.length){
    const s=fr.strokes[selectedStrokeIdx];
    if((s.type==='bezier'||s.type==='eraser')&&s.controls){
      const handles=getVisibleHandlePoints(fr.strokes,selectedStrokeIdx,activeP);
      for(const h of handles){
        const c=s.controls[h.idx];
        // 接線（始点→制御点→終点）
        ctx.save();ctx.strokeStyle='rgba(78,205,196,0.3)';ctx.lineWidth=1;
        ctx.beginPath();ctx.moveTo(c.sx,c.sy);ctx.lineTo(c.cx,c.cy);ctx.lineTo(c.ex,c.ey);ctx.stroke();
        // 制御点（ダイヤモンド型）
        const isActive=(dragPointInfo&&dragPointInfo.sub==='c'&&dragPointInfo.idx===h.idx);
        if(isActive){ctx.fillStyle='#fff';ctx.strokeStyle='#e94560';ctx.lineWidth=2.5;}
        else{ctx.fillStyle='rgba(78,205,196,0.7)';ctx.strokeStyle='rgba(78,205,196,0.9)';ctx.lineWidth=1.5;}
        ctx.beginPath();ctx.moveTo(h.x,h.y-r);ctx.lineTo(h.x+r,h.y);ctx.lineTo(h.x,h.y+r);ctx.lineTo(h.x-r,h.y);ctx.closePath();ctx.fill();ctx.stroke();
        ctx.restore();
      }
    }
  }

  // 通過点描画
  const pts=(selectedStrokeIdx>=0)?getStrokePathPoints(fr.strokes,selectedStrokeIdx):getStrokePathPoints(fr.strokes,-1);
  for(const pt of pts){
    ctx.save();
    const isDragging=(dragPointInfo&&dragPointInfo.strokeIdx===pt.strokeIdx&&dragPointInfo.idx===pt.idx&&dragPointInfo.sub===pt.sub);
    const isSelected=(!isDragging&&selectedPointInfo&&selectedPointInfo.strokeIdx===pt.strokeIdx&&selectedPointInfo.idx===pt.idx&&selectedPointInfo.sub===pt.sub);
    if(isDragging||isSelected){ctx.fillStyle='#fff';ctx.strokeStyle='#e94560';ctx.lineWidth=2.5;}
    else{ctx.fillStyle='rgba(233,69,96,0.8)';ctx.strokeStyle='#fff';ctx.lineWidth=1.5;}
    ctx.beginPath();ctx.arc(pt.x,pt.y,r,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.restore();
  }
}

// ===========================================================
// ストローク編集ツール（選択→移動/拡縮/回転）
// ===========================================================
function getStrokeBBox(s){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  const expand=(x,y)=>{if(x<minX)minX=x;if(x>maxX)maxX=x;if(y<minY)minY=y;if(y>maxY)maxY=y;};
  if(s.type==='bezier'||s.type==='eraser'){
    if(!s.controls)return null;
    for(const c of s.controls){expand(c.sx,c.sy);expand(c.cx,c.cy);expand(c.ex,c.ey);}
  }else if(s.type==='line'){expand(s.x1,s.y1);expand(s.x2,s.y2);}
  else if(s.type==='ellipse'){expand(s.cx-s.rx,s.cy-s.ry);expand(s.cx+s.rx,s.cy+s.ry);}
  else if(s.type==='rect'){expand(s.x,s.y);expand(s.x+s.w,s.y+s.h);}
  if(minX===Infinity)return null;
  const pad=4;
  return{x:minX-pad,y:minY-pad,w:maxX-minX+pad*2,h:maxY-minY+pad*2,cx:(minX+maxX)/2,cy:(minY+maxY)/2};
}

// BBoxから4頂点を生成
function bboxToCorners(bb){
  return[
    {x:bb.x,y:bb.y},           // tl
    {x:bb.x+bb.w,y:bb.y},      // tr
    {x:bb.x+bb.w,y:bb.y+bb.h}, // br
    {x:bb.x,y:bb.y+bb.h}       // bl
  ];
}
function cornersCenter(c){
  return{x:(c[0].x+c[1].x+c[2].x+c[3].x)/4,y:(c[0].y+c[1].y+c[2].y+c[3].y)/4};
}
// 回転ハンドル位置（上辺中央から20px外側）
function getRotateHandle(corners){
  const mx=(corners[0].x+corners[1].x)/2,my=(corners[0].y+corners[1].y)/2;
  const cx=(corners[0].x+corners[2].x)/2,cy=(corners[0].y+corners[2].y)/2;
  const dx=mx-cx,dy=my-cy;
  const len=Math.hypot(dx,dy)||1;
  return{x:mx+dx/len*20,y:my+dy/len*20};
}
// 点が回転した四角形の内部にあるか
function pointInQuad(p,c){
  // cross product sign check
  const cross=(ax,ay,bx,by)=>ax*by-ay*bx;
  for(let i=0;i<4;i++){
    const j=(i+1)%4;
    const ex=c[j].x-c[i].x,ey=c[j].y-c[i].y;
    const fx=p.x-c[i].x,fy=p.y-c[i].y;
    if(cross(ex,ey,fx,fy)<0)return false;
  }
  return true;
}

// ハンドル判定（回転対応）
function hitBBoxHandle(corners,center,p,threshold){
  if(!corners)return null;
  // 回転ハンドル
  const rh=getRotateHandle(corners);
  if(Math.hypot(p.x-rh.x,p.y-rh.y)<threshold)return 'rotate';
  // 角ハンドル
  const names=['tl','tr','br','bl'];
  for(let i=0;i<4;i++){
    if(Math.hypot(p.x-corners[i].x,p.y-corners[i].y)<threshold)return names[i];
  }
  // 本体内部
  if(pointInQuad(p,corners))return 'body';
  return null;
}

function transformStroke(s,cx,cy,dx,dy,sx,sy,angle){
  const cosA=Math.cos(angle),sinA=Math.sin(angle);
  const tr=(ox,oy)=>{
    let x=ox-cx,y=oy-cy;
    x*=sx;y*=sy;
    const rx=x*cosA-y*sinA,ry=x*sinA+y*cosA;
    return{x:rx+cx+dx,y:ry+cy+dy};
  };
  if(s.type==='bezier'||s.type==='eraser'){
    if(!s.controls)return;
    for(const c of s.controls){
      const ns=tr(c.sx,c.sy);c.sx=ns.x;c.sy=ns.y;
      const nc=tr(c.cx,c.cy);c.cx=nc.x;c.cy=nc.y;
      const ne=tr(c.ex,c.ey);c.ex=ne.x;c.ey=ne.y;
    }
  }else if(s.type==='line'){
    const a=tr(s.x1,s.y1),b=tr(s.x2,s.y2);
    s.x1=a.x;s.y1=a.y;s.x2=b.x;s.y2=b.y;
  }else if(s.type==='ellipse'){
    const ct=tr(s.cx,s.cy);s.cx=ct.x;s.cy=ct.y;
    s.rx=Math.max(1,s.rx*sx);s.ry=Math.max(1,s.ry*sy);
  }else if(s.type==='rect'){
    const a=tr(s.x,s.y),b=tr(s.x+s.w,s.y+s.h);
    s.x=Math.min(a.x,b.x);s.y=Math.min(a.y,b.y);
    s.w=Math.abs(b.x-a.x);s.h=Math.abs(b.y-a.y);
  }
}

// 頂点配列を同じ変換で動かす
function transformCorners(corners,cx,cy,dx,dy,sx,sy,angle){
  const cosA=Math.cos(angle),sinA=Math.sin(angle);
  return corners.map(pt=>{
    let x=pt.x-cx,y=pt.y-cy;
    x*=sx;y*=sy;
    const rx=x*cosA-y*sinA,ry=x*sinA+y*cosA;
    return{x:rx+cx+dx,y:ry+cy+dy};
  });
}

function initStrokeEditBox(si,strokes){
  const bb=getStrokeBBox(strokes[si]);
  if(!bb)return;
  strokeEditCorners=bboxToCorners(bb);
  strokeEditCenter=cornersCenter(strokeEditCorners);
}

function onDownStroke(p,e){
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return;
  const hitR=8/S.zoom;
  // 既に選択中ならハンドル判定
  if(strokeEditIdx>=0&&strokeEditCorners){
    const h=hitBBoxHandle(strokeEditCorners,strokeEditCenter,p,hitR);
    if(h){
      pushUndo();
      strokeEditStart={x:p.x,y:p.y};
      if(h==='body'){strokeEditMode='move';}
      else if(h==='rotate'){
        strokeEditMode='rotate';
        const ax=strokeEditAnchor?strokeEditAnchor.x:strokeEditCenter.x;
        const ay=strokeEditAnchor?strokeEditAnchor.y:strokeEditCenter.y;
        strokeEditInitAngle=Math.atan2(p.y-ay,p.x-ax);
      }else{
        strokeEditMode='scale';
        // アンカーポイントを軸に拡大縮小（アンカーがない場合は中心を使用）
        const ax=strokeEditAnchor?strokeEditAnchor.x:strokeEditCenter.x;
        const ay=strokeEditAnchor?strokeEditAnchor.y:strokeEditCenter.y;
        strokeEditInitScale=Math.hypot(p.x-ax,p.y-ay);
      }
      return;
    }
  }
  // ストローク選択（クリック位置をアンカーとして記録）
  const si=hitTestStroke(fr.strokes,p,hitR);
  if(si>=0){
    strokeEditIdx=si;
    initStrokeEditBox(si,fr.strokes);
    strokeEditAnchor={x:p.x,y:p.y};
    strokeEditMode='';
  }else{
    strokeEditIdx=-1;strokeEditCorners=null;strokeEditCenter=null;strokeEditAnchor=null;strokeEditMode='';
  }
  renderAll();
}

function onMoveStroke(p,e){
  if(strokeEditIdx<0||!strokeEditStart||!strokeEditMode)return;
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return;
  const s=fr.strokes[strokeEditIdx];

  if(strokeEditMode==='move'){
    const dx=p.x-strokeEditStart.x,dy=p.y-strokeEditStart.y;
    offsetStroke(s,dx,dy);
    // ボックスとアンカーも一緒に移動
    strokeEditCorners=strokeEditCorners.map(c=>({x:c.x+dx,y:c.y+dy}));
    strokeEditCenter={x:strokeEditCenter.x+dx,y:strokeEditCenter.y+dy};
    if(strokeEditAnchor)strokeEditAnchor={x:strokeEditAnchor.x+dx,y:strokeEditAnchor.y+dy};
    strokeEditStart={x:p.x,y:p.y};
  }else if(strokeEditMode==='scale'){
    // アンカーポイントを軸に拡大縮小（アンカーがない場合は中心を使用）
    const ax=strokeEditAnchor?strokeEditAnchor.x:strokeEditCenter.x;
    const ay=strokeEditAnchor?strokeEditAnchor.y:strokeEditCenter.y;
    const dist=Math.hypot(p.x-ax,p.y-ay);
    const scale=dist/Math.max(1,strokeEditInitScale);
    transformStroke(s,ax,ay,0,0,scale,scale,0);
    strokeEditCorners=transformCorners(strokeEditCorners,ax,ay,0,0,scale,scale,0);
    strokeEditCenter=cornersCenter(strokeEditCorners);
    // アンカー自体は固定（動かさない）
    strokeEditInitScale=dist;
  }else if(strokeEditMode==='rotate'){
    const ax=strokeEditAnchor?strokeEditAnchor.x:strokeEditCenter.x;
    const ay=strokeEditAnchor?strokeEditAnchor.y:strokeEditCenter.y;
    const angle=Math.atan2(p.y-ay,p.x-ax);
    const da=angle-strokeEditInitAngle;
    transformStroke(s,ax,ay,0,0,1,1,da);
    strokeEditCorners=transformCorners(strokeEditCorners,ax,ay,0,0,1,1,da);
    strokeEditCenter=cornersCenter(strokeEditCorners);
    strokeEditInitAngle=angle;
  }
  renderAll();
}

function onUpStroke(p,e){
  strokeEditMode='';strokeEditStart=null;
}

// ストローク編集オーバーレイ描画（回転対応バウンディングボックス+ハンドル）
function renderStrokeEditOverlay(){
  if(S.tool!=='stroke'||strokeEditIdx<0||!strokeEditCorners)return;
  const ctx=pointEditCtx;
  const c=strokeEditCorners;
  const r=5;

  ctx.save();
  // 回転対応バウンディングボックス（四角形パス）
  ctx.strokeStyle='rgba(78,205,196,0.8)';ctx.lineWidth=1.5;ctx.setLineDash([6,3]);
  ctx.beginPath();
  ctx.moveTo(c[0].x,c[0].y);ctx.lineTo(c[1].x,c[1].y);ctx.lineTo(c[2].x,c[2].y);ctx.lineTo(c[3].x,c[3].y);ctx.closePath();
  ctx.stroke();ctx.setLineDash([]);

  // 回転ハンドルへの線
  const rh=getRotateHandle(c);
  ctx.strokeStyle='rgba(78,205,196,0.4)';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo((c[0].x+c[1].x)/2,(c[0].y+c[1].y)/2);ctx.lineTo(rh.x,rh.y);ctx.stroke();

  // 回転ハンドル（紫丸）
  ctx.fillStyle='rgba(168,85,247,0.8)';ctx.strokeStyle='#fff';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.arc(rh.x,rh.y,r,0,Math.PI*2);ctx.fill();ctx.stroke();

  // 角ハンドル（四角）
  ctx.fillStyle='rgba(78,205,196,0.8)';ctx.strokeStyle='#fff';ctx.lineWidth=1.5;
  for(let i=0;i<4;i++){
    ctx.beginPath();ctx.rect(c[i].x-r,c[i].y-r,r*2,r*2);ctx.fill();ctx.stroke();
  }

  // アンカーポイント（回転軸）表示
  if(strokeEditAnchor){
    const ax=strokeEditAnchor.x,ay=strokeEditAnchor.y;
    ctx.strokeStyle='rgba(233,69,96,0.9)';ctx.lineWidth=1.5;
    ctx.beginPath();ctx.moveTo(ax-6,ay);ctx.lineTo(ax+6,ay);ctx.stroke();
    ctx.beginPath();ctx.moveTo(ax,ay-6);ctx.lineTo(ax,ay+6);ctx.stroke();
    ctx.beginPath();ctx.arc(ax,ay,4,0,Math.PI*2);ctx.strokeStyle='rgba(233,69,96,0.7)';ctx.stroke();
  }
  ctx.restore();
}

// ===========================================================
// 全体移動ツール
// ===========================================================
function onDownMove(p,e){
  const fr=CF()[S.layer].frames[S.frame];if(!fr||fr.strokes.length===0)return;
  pushUndo();
  moveDragging=true;moveMode='all';moveDragStart={x:p.x,y:p.y};
}

function onMoveMove(p,e){
  if(!moveDragging||!moveDragStart)return;
  const dx=p.x-moveDragStart.x,dy=p.y-moveDragStart.y;
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return;
  for(const s of fr.strokes)offsetStroke(s,dx,dy);
  moveDragStart={x:p.x,y:p.y};
  renderAll();
}

function onUpMove(p,e){
  moveDragging=false;moveDragStart=null;
}

function offsetStroke(s,dx,dy){
  if(s.type==='bezier'||s.type==='eraser'){
    if(!s.controls)return;
    for(const c of s.controls){c.sx+=dx;c.sy+=dy;c.cx+=dx;c.cy+=dy;c.ex+=dx;c.ey+=dy;}
  }else if(s.type==='line'){
    s.x1+=dx;s.y1+=dy;s.x2+=dx;s.y2+=dy;
  }else if(s.type==='ellipse'){
    s.cx+=dx;s.cy+=dy;
  }else if(s.type==='rect'){
    s.x+=dx;s.y+=dy;
  }
}

// ===========================================================
// ストロークポイント数調整（リサンプリング）
// ===========================================================
// ベジェ曲線をt値で評価して通過点列を得る
function sampleBezierPath(controls,numSamples){
  if(!controls||controls.length===0)return[];
  const pts=[];
  const totalSegs=controls.length;
  for(let i=0;i<numSamples;i++){
    const globalT=i/(numSamples-1)*totalSegs;
    const segIdx=Math.min(Math.floor(globalT),totalSegs-1);
    const localT=globalT-segIdx;
    const c=controls[segIdx];
    const t=localT,mt=1-t;
    pts.push({x:mt*mt*c.sx+2*mt*t*c.cx+t*t*c.ex,y:mt*mt*c.sy+2*mt*t*c.cy+t*t*c.ey});
  }
  return pts;
}
// 通過点列からベジェ制御点列を再構築（Catmull-Rom→ベジェ変換）
function fitBezierToPoints(pts){
  if(pts.length<2)return[];
  const controls=[];
  for(let i=0;i<pts.length-1;i++){
    const p0=pts[Math.max(0,i-1)];
    const p1=pts[i];
    const p2=pts[i+1];
    const p3=pts[Math.min(pts.length-1,i+2)];
    // Catmull-Rom to cubic bezier, then cubic→quadratic approximation
    const cx1=p1.x+(p2.x-p0.x)/6;
    const cy1=p1.y+(p2.y-p0.y)/6;
    const cx2=p2.x-(p3.x-p1.x)/6;
    const cy2=p2.y-(p3.y-p1.y)/6;
    // quadratic control point = midpoint of cubic control points
    const qcx=(cx1+cx2)/2;
    const qcy=(cy1+cy2)/2;
    controls.push({sx:p1.x,sy:p1.y,cx:qcx,cy:qcy,ex:p2.x,ey:p2.y});
  }
  return controls;
}
// ストロークのポイント数をリサンプリング
function resampleStrokePoints(s,newCount){
  if(s.type!=='bezier'||!s.controls||s.controls.length===0)return;
  // 元の曲線上の通過点を多めにサンプリング
  const denseSamples=sampleBezierPath(s.controls,Math.max(200,newCount*10));
  // 等距離で間引いてnewCount個の通過点を得る
  const totalLen=[];let len=0;totalLen.push(0);
  for(let i=1;i<denseSamples.length;i++){
    len+=Math.hypot(denseSamples[i].x-denseSamples[i-1].x,denseSamples[i].y-denseSamples[i-1].y);
    totalLen.push(len);
  }
  const step=len/(newCount);
  const keyPts=[denseSamples[0]];
  let nextDist=step;
  for(let i=1;i<denseSamples.length;i++){
    if(totalLen[i]>=nextDist){
      keyPts.push(denseSamples[i]);
      nextDist+=step;
    }
  }
  // 必ず終点を含める
  const last=denseSamples[denseSamples.length-1];
  if(keyPts.length>0&&Math.hypot(keyPts[keyPts.length-1].x-last.x,keyPts[keyPts.length-1].y-last.y)>0.5){
    keyPts.push(last);
  }
  if(keyPts.length<2)return;
  s.controls=fitBezierToPoints(keyPts);
}
// スライダー表示更新
function getSelectedStrokeForSlider(){
  const fr=CF()[S.layer].frames[S.frame];if(!fr)return null;
  let idx=-1;
  if(S.tool==='stroke'&&strokeEditIdx>=0)idx=strokeEditIdx;
  else if(S.tool==='point'&&selectedStrokeIdx>=0)idx=selectedStrokeIdx;
  if(idx<0||idx>=fr.strokes.length)return null;
  const s=fr.strokes[idx];
  if(s.type!=='bezier'||!s.controls)return null;
  return s;
}
function updateStrokePointSlider(){
  const slider=document.getElementById('stroke-point-slider');
  const val=document.getElementById('stroke-point-val');
  const s=getSelectedStrokeForSlider();
  if(!s){val.textContent='-';slider.value=10;slider.disabled=true;return;}
  const n=s.controls.length+1; // 通過点の数=セグメント数+1
  val.textContent=n;
  slider.value=n;
  slider.min=2;
  slider.max=Math.max(n*3,100);
  slider.disabled=false;
}
let _strokePointSliderBak=null; // undo用のバックアップ
function onStrokePointSliderInput(e){
  const s=getSelectedStrokeForSlider();if(!s)return;
  const newPts=+e.target.value;
  if(newPts<2)return;
  // 初回ドラッグ時にundoバックアップ
  if(!_strokePointSliderBak){
    pushUndo();
    _strokePointSliderBak=JSON.parse(JSON.stringify(s.controls));
  }
  // 元のバックアップからリサンプリング（累積劣化防止）
  const tmpS={type:'bezier',controls:JSON.parse(JSON.stringify(_strokePointSliderBak))};
  resampleStrokePoints(tmpS,newPts);
  s.controls=tmpS.controls;
  document.getElementById('stroke-point-val').textContent=s.controls.length+1;
  renderAll();
}
// スライダー離した時にバックアップをクリア
document.addEventListener('mouseup',()=>{_strokePointSliderBak=null;});

// ===========================================================
// オニオンスキン
// ===========================================================
function renderOnion(){
  onionCtx.clearRect(0, 0, S.cw, S.ch);
  if(!document.getElementById('onion-enabled').checked){
    onionCanvas.style.display = 'none';
    return;
  }
  onionCanvas.style.display = 'block';

  const pv = +document.getElementById('onion-prev').value || 0;
  const nx = +document.getElementById('onion-next').value || 0;

  for(let d = 1; d <= pv; d++){
    const fi = S.frame - d;
    if(fi < 0) continue;
    drawOnionFrame(fi, `rgba(233,69,96,${0.25/d})`);
  }
  
  for(let d = 1; d <= nx; d++){
    const fi = S.frame + d;
    if(fi >= CTF()) continue;
    drawOnionFrame(fi, `rgba(78,205,196,${0.25/d})`);
  }
}
function drawOnionFrame(fi, col){
  // ★ ここも逆順にした
  for(let li = LAYER_DEFS.length - 1; li >= 0; li--){
    if(!layerVis[li] || !onionLayerVis[li]) continue;

    const fr = getEffectiveFrame(li, fi);
    if(!fr) continue;

    if(fr.draftImg){
      const key = 'onion-' + li + '-' + fi;
      if(draftImgCache[key] && draftImgCache[key].src === fr.draftImg){
        onionCtx.globalAlpha = 0.5;
        onionCtx.drawImage(draftImgCache[key], 0, 0, S.cw, S.ch);
        onionCtx.globalAlpha = 1;
      } else {
        const img = new Image();
        img.onload = () => {
          draftImgCache[key] = img;
          onionCtx.globalAlpha = 0.5;
          onionCtx.drawImage(img, 0, 0, S.cw, S.ch);
          onionCtx.globalAlpha = 1;
        };
        img.src = fr.draftImg;
      }
    }

    for(const s of fr.strokes){
      if(s.type === 'eraser') continue;
      drawStroke(onionCtx, { ...s, color: col });
    }
  }
}
function toggleOnionSkin(){const cb=document.getElementById('onion-enabled');cb.checked=!cb.checked;renderAll();}

function renderStrokeGuide() {
  guideCtx.clearRect(0, 0, S.cw, S.ch);
  
  // チェックが入っていない or 非表示なら何もしない
  if (!document.getElementById('stroke-guide-enabled').checked) {
    guideCanvas.style.display = 'none';
    return;
  }
  
  guideCanvas.style.display = 'block';
  
  const prevFi = S.frame - 1;
  if (prevFi < 0) return;
  
  const li = S.layer;
  if (!layerVis[li]) return;
  
  const fr = getEffectiveFrame(li, prevFi);
  if (!fr) return;
  
  // 消しゴムは除外し、描画順（order）でソート
  const strokes = [...fr.strokes]
    .filter(s => s.type !== 'eraser')
    .sort((a, b) => a.order - b.order);
  
  // ★ フィルターが有効な場合は該当する番号のみ描画 ★
  for (let idx = 0; idx < strokes.length; idx++) {
    const strokeNum = idx + 1;
    
    // フィルターが設定されていて、かつ一致しない場合はスキップ
    if (strokeOrderFilter !== null && strokeOrderFilter !== strokeNum) {
      continue;
    }
    
    drawStrokeGuideAnnotation(guideCtx, strokes[idx], strokeNum);
  }
}
function drawStrokeGuideAnnotation(ctx, s, num) {
  // ストロークのパスをサンプリングしてポイント列を取得
  let pathPts = [];
  if (s.type === 'bezier' && s.controls && s.controls.length > 0) {
    for (let i = 0; i < s.controls.length; i++) {
      const c = s.controls[i];
      const steps = 10;
      for (let t = 0; t <= steps; t++) {
        if (i > 0 && t === 0) continue;
        const tt = t / steps, u = 1 - tt;
        pathPts.push({
          x: u*u*c.sx + 2*u*tt*c.cx + tt*tt*c.ex,
          y: u*u*c.sy + 2*u*tt*c.cy + tt*tt*c.ey
        });
      }
    }
  } else if (s.type === 'line') {
    const n = 20;
    for (let i = 0; i <= n; i++) {
      pathPts.push({
        x: s.x1 + (s.x2 - s.x1) * i / n,
        y: s.y1 + (s.y2 - s.y1) * i / n
      });
    }
  } else if (s.type === 'ellipse') {
    const n = 40;
    for (let i = 0; i <= n; i++) {
      const a = Math.PI * 2 * i / n;
      pathPts.push({ x: s.cx + s.rx * Math.cos(a), y: s.cy + s.ry * Math.sin(a) });
    }
  } else if (s.type === 'rect') {
    pathPts.push(
      {x:s.x, y:s.y},
      {x:s.x+s.w, y:s.y},
      {x:s.x+s.w, y:s.y+s.h},
      {x:s.x, y:s.y+s.h},
      {x:s.x, y:s.y}
    );
  } else return;

  if (pathPts.length < 2) return;

  // 累積距離を計算
  const dists = [0];
  for (let i = 1; i < pathPts.length; i++) {
    const dx = pathPts[i].x - pathPts[i-1].x;
    const dy = pathPts[i].y - pathPts[i-1].y;
    dists.push(dists[i-1] + Math.hypot(dx, dy));
  }
  const totalLen = dists[dists.length - 1];
  if (totalLen < 5) return;

  // ── 始点の番号丸（サイズ少し小さくしても見やすい範囲で） ──
  const sp = pathPts[0];
  const nd = Math.min(3, pathPts.length - 1);
  const startDx = pathPts[nd].x - sp.x;
  const startDy = pathPts[nd].y - sp.y;
  const startDist = Math.hypot(startDx, startDy) || 1;
  const offX = -startDx / startDist * 18;
  const offY = -startDy / startDist * 18;

  ctx.save();
  ctx.strokeStyle = 'rgba(233,69,96,0.9)';
  ctx.lineWidth = 1.8;
  ctx.beginPath();
  ctx.arc(sp.x + offX, sp.y + offY, 9, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = 'rgba(233,69,96,0.9)';
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(String(num), sp.x + offX, sp.y + offY);
  ctx.restore();

  // ── チェブロン（＞）を最大3つまで表示 ───────────────────────
  const MAX_CHEVRONS = 3;
  const chevronInterval = totalLen / (MAX_CHEVRONS + 1.5);  // 少し余裕を持たせる
  const chevronSize = 9;  // ← ここ！小さくした（元14→9）

  ctx.save();
  ctx.strokeStyle = 'rgba(233,69,96,0.75)';
  ctx.lineWidth = 2.2;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  let count = 0;
  let d = chevronInterval * 0.8;  // 最初を少し遅らせて始点と被らないように

  while (d < totalLen && count < MAX_CHEVRONS) {
    // dの位置を探す
    let pi = 0;
    for (let i = 1; i < dists.length; i++) {
      if (dists[i] >= d) { pi = i; break; }
    }
    if (pi === 0) pi = dists.length - 1;

    const seg = dists[pi] - dists[pi - 1] || 1;
    const t = (d - dists[pi - 1]) / seg;
    const px = pathPts[pi - 1].x + (pathPts[pi].x - pathPts[pi - 1].x) * t;
    const py = pathPts[pi - 1].y + (pathPts[pi].y - pathPts[pi - 1].y) * t;

    // 進行方向（少し先を見た平均方向）
    const lookAhead = Math.min(pi + 3, pathPts.length - 1);
    const lookBehind = Math.max(pi - 2, 0);
    const dirX = pathPts[lookAhead].x - pathPts[lookBehind].x;
    const dirY = pathPts[lookAhead].y - pathPts[lookBehind].y;
    const dirLen = Math.hypot(dirX, dirY) || 1;
    const nx = dirX / dirLen;
    const ny = dirY / dirLen;

    const perpX = -ny;
    const perpY = nx;

    const tipX = px + nx * chevronSize * 0.5;
    const tipY = py + ny * chevronSize * 0.5;
    const backX = px - nx * chevronSize * 0.5;
    const backY = py - ny * chevronSize * 0.5;

    ctx.beginPath();
    ctx.moveTo(backX + perpX * chevronSize * 0.7, backY + perpY * chevronSize * 0.7);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(backX - perpX * chevronSize * 0.7, backY - perpY * chevronSize * 0.7);
    ctx.stroke();

    d += chevronInterval;
    count++;
  }

  ctx.restore();
}
function toggleStrokeGuide(){const cb=document.getElementById('stroke-guide-enabled');cb.checked=!cb.checked;renderAll();}

// ===========================================================
// カット管理
// ===========================================================
function updateCutList(){
  const list=document.getElementById('cut-list');list.innerHTML='';
  for(let i=0;i<cuts.length;i++){const c=cuts[i];const item=document.createElement('div');item.className='cut-item'+(i===currentCut?' active':'');item.onclick=()=>switchCut(i);
    const lbl=document.createElement('span');lbl.className='cut-label';lbl.textContent=c.name;
    const info=document.createElement('span');info.className='cut-frames';info.textContent=c.totalFrames+'f';
    item.appendChild(lbl);item.appendChild(info);list.appendChild(item);}
  document.getElementById('current-cut-display').textContent=CC().name;
}
function switchCut(idx){currentCut=idx;S.frame=0;updateCutList();updateLayerList();updateTimeline();renderAll();}
function addCut(){const num=cuts.length+1;const name='C_'+String(num).padStart(3,'0');cuts.push(createEmptyCut(name,24));switchCut(cuts.length-1);notify(`カット ${name} を追加`);}
function removeCut(){if(cuts.length<=1){notify('最後のカットは削除できません');return;}if(!confirm(`${CC().name} を削除しますか？`))return;cuts.splice(currentCut,1);if(currentCut>=cuts.length)currentCut=cuts.length-1;for(let i=0;i<cuts.length;i++)cuts[i].name='C_'+String(i+1).padStart(3,'0');S.frame=0;updateCutList();updateLayerList();updateTimeline();renderAll();notify('カットを削除');}

// ===========================================================
// レイヤー
// ===========================================================
function updateLayerList(){
  const list = document.getElementById('layer-list');
  list.innerHTML = '';

  for(let i = 0; i < LAYER_DEFS.length; i++){
    const d = LAYER_DEFS[i];

    const item = document.createElement('div');
    item.className = 'layer-item' + (i === S.layer ? ' active' : '');
    item.onclick = () => {
      S.layer = i;
      updateLayerList();
      renderAll();
    };

    // 色ドット
    const dot = document.createElement('div');
    dot.className = 'layer-color-dot';
    dot.style.background = d.color;

    // レイヤー名
    const nm = document.createElement('div');
    nm.className = 'layer-name';
    nm.textContent = d.name;

    // ★ 新規追加：🎨 ボタン（線画色一括変更用）
    const colorBtn = document.createElement('button');
    colorBtn.className = 'layer-color-btn';
    colorBtn.textContent = '🎨';
    colorBtn.title = 'このレイヤーの線画色を一括変更';
    colorBtn.onclick = (e) => {
      e.stopPropagation();               // 親のレイヤー選択クリックをキャンセル
      showLayerColorPalette(i, e);       // パレット表示関数を呼ぶ
    };

    // 表示/非表示ボタン（👁）
    const vis = document.createElement('button');
    vis.className = 'layer-vis-btn' + (layerVis[i] ? '' : ' hidden');
    vis.textContent = layerVis[i] ? '👁' : '🚫';
    vis.title = '表示切替';
    vis.onclick = (e) => {
      e.stopPropagation();
      layerVis[i] = !layerVis[i];
      updateLayerList();
      renderAll();
    };

    // オニオンスキンボタン（🧅）
    const onion = document.createElement('button');
    onion.className = 'layer-onion-btn' + (onionLayerVis[i] ? ' active' : '');
    onion.textContent = '🧅';
    onion.title = 'オニオンスキン';
    onion.onclick = (e) => {
      e.stopPropagation();
      onionLayerVis[i] = !onionLayerVis[i];
      updateLayerList();
      renderAll();
    };

    // 追加順序：色丸 → 名前 → 🎨 → 👁 → 🧅
    item.appendChild(dot);
    item.appendChild(nm);
    item.appendChild(colorBtn);    // ← これが新しいボタン
    item.appendChild(vis);
    item.appendChild(onion);

    list.appendChild(item);
  }
}
function clearCurrentLayer(){pushUndo();CF()[S.layer].frames[S.frame]={strokes:[],draftImg:null};renderAll();notify('クリア');}
function clearAllLayers(){if(!confirm('現在のフレームの全レイヤーをクリアしますか？'))return;pushUndo();for(let i=0;i<LAYER_DEFS.length;i++)CF()[i].frames[S.frame]={strokes:[],draftImg:null};renderAll();notify('全レイヤークリア');}
function duplicateFrame(){pushUndo();const nf=S.frame+1;if(nf<CTF()){CF()[S.layer].frames[nf]=JSON.parse(JSON.stringify(CF()[S.layer].frames[S.frame]));goToFrame(nf);notify('フレームを複製');}}

// ===========================================================
// タイムライン（レイヤーラベルと行を逆順表示）
// ===========================================================
function updateTimeline() {
  // まず音声タイムラインを更新（必要に応じて）
  updateAudioTimeline();

  const tf = CTF();
  console.log("[updateTimeline] tf =", tf);
  console.log("[updateTimeline] cuts[currentCut].totalFrames =", cuts[currentCut].totalFrames);

  // ── 左側：レイヤーラベル（固定） ────────────────
  const labelsInner = document.getElementById('tl-layer-labels-inner');
  if (labelsInner) {
    labelsInner.innerHTML = '';

    for (let i = 0; i < LAYER_DEFS.length; i++) {
      const d = LAYER_DEFS[i];
      const label = document.createElement('div');
      label.className = 'tl-layer-label' + (i === S.layer ? ' active' : '');
      label.onclick = () => {
        S.layer = i;
        updateLayerList();
        updateTimeline();
        renderAll();
      };
      const dot = document.createElement('span');
      dot.className = 'dot';
      dot.style.background = d.color;
      label.appendChild(dot);
      label.appendChild(document.createTextNode(d.name));
      labelsInner.appendChild(label);
    }
  }

  // ── 右側：フレームヘッダー＋セル ────────────────
const header = document.getElementById('tl-header');
if (header) header.innerHTML = '';

const rows = document.getElementById('tl-rows');
if (rows) rows.innerHTML = '';



console.log("[Timeline] 現在の総フレーム数:", tf); // デバッグ用

// フレーム番号ヘッダー（これが42で止まらないか確認）
for (let f = 0; f < tf; f++) {
  const d = document.createElement('div');
  d.className = 'tl-frame-num' + (f === S.frame ? ' current' : '');
  d.textContent = f + 1;
  d.onclick = () => goToFrame(f);
  header?.appendChild(d);
}

// 各レイヤーのセル行
for (let i = 0; i < LAYER_DEFS.length; i++) {
  const row = document.createElement('div');
  row.className = 'tl-row';
  for (let f = 0; f < tf; f++) {  // ← tf まで確実にループ
    const cell = document.createElement('div');
    cell.className = 'tl-cell';
    if (f === S.frame) cell.classList.add('current-frame');

    const fr = CF()[i].frames[f];
    const hasData = fr && (fr.strokes.length > 0 || fr.draftImg);
    if (hasData) cell.classList.add('has-data');

    const dk = i + '-' + f;
    const durVal = CFD()[dk] || 1;
    if (durVal > 1) {
      cell.classList.add('hold-start');
      cell.title = durVal + 'f持続';
    } else {
      const eidx = getEffectiveFrameIdx(i, f);
      if (eidx !== f) {
        cell.classList.add('hold-frame');
        cell.title = '← フレーム' + (eidx + 1) + 'の持続';
      }
    }

    if (tlSelected.has(i + '-' + f)) cell.classList.add('tl-selected');

    cell.dataset.li = i;
    cell.dataset.fi = f;
    cell.addEventListener('mousedown', e => tlCellMouseDown(e, i, f));
    cell.addEventListener('contextmenu', e => showCtxMenu(e, i, f));

    row.appendChild(cell);
  }
  rows?.appendChild(row);
}

// デバッグ：実際に生成されたセル数を確認
console.log("[Timeline] 生成されたセル行数:", rows?.children.length);
console.log("[Timeline] 1行あたりのセル数:", rows?.children[0]?.children.length);

  document.getElementById('current-frame-display').textContent = S.frame + 1;
  document.getElementById('total-frame-display').textContent = tf;
  document.getElementById('info-frames').value = tf;

  updateTimelineHeight();
  setupTimelineScrollSync();

  // 必要に応じて音声再生ヘッドも更新
  updateAudioPlayhead();
}
function updateAudioTimeline() {
  // もう動的に生成・削除しない（HTMLで固定配置済みなので）
  // 波形だけ更新すればOK
  if (audioBuffer) {
    drawAudioWaveform();
  } else {
    const canvas = document.getElementById('audio-waveform-canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'var(--text-muted)';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('音声なし', canvas.width / 2, canvas.height / 2 + 3);
    }
  }
  updateAudioPlayhead();
}

function updateAudioPlayhead() {
  const playhead = document.getElementById('audio-playhead');
  if (!playhead) return;

  if (audioState.file && audioBuffer) {
    const cellWidth = 28;
    const x = S.frame * cellWidth;
    playhead.style.left = x + 'px';
    playhead.style.display = 'block';
  } else {
    playhead.style.display = 'none';
  }
}

// 以下は変更なし（そのままコピー）
function updateTimelineHeight(){
  const ctrl = document.getElementById('timeline-controls');
  const ctrlH = ctrl ? ctrl.offsetHeight : 32;
  const h = ctrlH + 18 + (LAYER_DEFS.length + 1) * 24 + 4;
  document.getElementById('timeline-panel').style.height = h + 'px';
}

function setupTimelineScrollSync() {
  const left = document.getElementById('tl-left-fixed');
  const right = document.getElementById('tl-right-scrollable');

  if (!left || !right) return;

  // 右側の縦スクロール → 左側に反映
  right.addEventListener('scroll', () => {
    left.scrollTop = right.scrollTop;
  });

  // 左側の縦スクロール → 右側に反映（双方向同期）
  left.addEventListener('scroll', () => {
    right.scrollTop = left.scrollTop;
  });
}
function goToFrame(f) {
  if (f < 0 || f >= CTF()) return;
  if (S.frame === f) return;

  S.frame = f;

  // 音声再生ヘッドを即時更新
  updateAudioPlayhead();

  renderAll();
  updateTimeline();
  document.getElementById('current-frame-display').textContent = S.frame + 1;
}
function tlGetSelectedOnLayer(li){
  const arr = [];
  for(const k of tlSelected){
    const p = k.split('-');
    if(+p[0] === li) arr.push(+p[1]);
  }
  arr.sort((a,b) => a - b);
  return arr;
}

function tlCellMouseDown(e, li, fi){
  if(e.button !== 0) return;
  e.preventDefault();

  const fr = CF()[li].frames[fi];
  const hasData = fr && (fr.strokes.length > 0 || fr.draftImg);
  const durVal = CFD()[li + '-' + fi] || 1;
  const isKeyCell = hasData || durVal > 1;
  const key = li + '-' + fi;

  if(e.shiftKey){
    if(isKeyCell){
      if(tlSelected.has(key)) tlSelected.delete(key);
      else tlSelected.add(key);
    }
    S.layer = li;
    goToFrame(fi);
    updateLayerList();
    return;
  }

  if(tlSelected.has(key) || isKeyCell){
    tlDragging = true;
    tlDragSource = { li, fi };
    tlDragCurrent = fi;

    if(!tlSelected.has(key) && !e.shiftKey){
      tlSelected.clear();
      if(isKeyCell) tlSelected.add(key);
    }

    const onMove = ev => {
      const cell = document.elementFromPoint(ev.clientX, ev.clientY);
      if(cell && cell.dataset && cell.dataset.fi !== undefined){
        const newFi = +cell.dataset.fi;
        if(newFi !== tlDragCurrent){
          tlDragCurrent = newFi;
          updateTimeline();
        }
      }
    };

    const onUp = ev => {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);

      if(tlDragging && tlDragCurrent !== null && tlDragCurrent !== tlDragSource.fi){
        tlApplyDrag();
      } else {
        if(!e.shiftKey) tlSelected.clear();
        S.layer = li;
        goToFrame(fi);
        updateLayerList();
      }

      tlDragging = false;
      tlDragSource = null;
      tlDragCurrent = null;
      updateTimeline();
    };

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  } else {
    if(!e.shiftKey) tlSelected.clear();
    S.layer = li;
    goToFrame(fi);
    updateLayerList();
  }
}

function tlApplyDrag(){
  if(!tlDragSource) return;
  const delta = tlDragCurrent - tlDragSource.fi;
  if(delta === 0) return;
  pushUndo();

  const layerMap = {};
  for(const k of tlSelected){
    const p = k.split('-');
    const li = +p[0], fi = +p[1];
    if(!layerMap[li]) layerMap[li] = [];
    layerMap[li].push(fi);
  }

  const tf = CTF();
  for(const liStr in layerMap){
    const li = +liStr;
    const srcFrames = layerMap[li].sort((a,b) => a - b);
    const frames = CF()[li].frames;
    const dur = CFD();

    const minDst = srcFrames[0] + delta;
    const maxDst = srcFrames[srcFrames.length - 1] + delta;
    if(minDst < 0 || maxDst >= tf) continue;

    const saved = [];
    for(const fi of srcFrames){
      saved.push({
        fi,
        data: JSON.parse(JSON.stringify(frames[fi])),
        dur: dur[li + '-' + fi] || 1
      });
    }

    for(const fi of srcFrames){
      frames[fi] = { strokes: [], draftImg: null };
      delete dur[li + '-' + fi];
    }

    const displaced = [];
    for(const s of saved){
      const dst = s.fi + delta;
      if(!srcFrames.includes(dst)){
        displaced.push({
          fi: dst,
          data: JSON.parse(JSON.stringify(frames[dst])),
          dur: dur[li + '-' + dst] || 1
        });
      }
      frames[dst] = s.data;
      if(s.dur > 1) dur[li + '-' + dst] = s.dur;
      else delete dur[li + '-' + dst];
    }

    for(const d of displaced){
      for(const fi of srcFrames){
        const curFr = frames[fi];
        if(curFr && curFr.strokes.length === 0 && !curFr.draftImg){
          frames[fi] = d.data;
          if(d.dur > 1) dur[li + '-' + fi] = d.dur;
          break;
        }
      }
    }
  }

  const newSel = new Set();
  for(const k of tlSelected){
    const p = k.split('-');
    const li = +p[0], fi = +p[1];
    const dst = fi + delta;
    if(dst >= 0 && dst < tf) newSel.add(li + '-' + dst);
  }
  tlSelected = newSel;

  goToFrame(Math.max(0, Math.min(tf - 1, S.frame + delta)));
}

function goNextFrame(){ goToFrame(S.frame + 1); }
function goPrevFrame(){ goToFrame(S.frame - 1); }
function goFirstFrame(){ goToFrame(0); }
function goLastFrame(){ goToFrame(CTF() - 1); }

function addFrame(){
  CC().totalFrames++;
  for(let i = 0; i < LAYER_DEFS.length; i++){
    CF()[i].frames.push({ strokes: [], draftImg: null });
  }
  updateTimeline();
}

function removeFrame(){
  if(CTF() <= 1) return;
  pushUndo();
  for(let i = 0; i < LAYER_DEFS.length; i++){
    CF()[i].frames.splice(S.frame, 1);
  }
  CC().totalFrames--;
  if(S.frame >= CTF()) S.frame = CTF() - 1;
  updateTimeline();
  renderAll();
}

function insertKeyframe(){
  pushUndo();
  const f = S.frame + 1;
  for(let i = 0; i < LAYER_DEFS.length; i++){
    CF()[i].frames.splice(f, 0, { strokes: [], draftImg: null });
  }
  CC().totalFrames++;
  goToFrame(f);
  notify('キーフレームを挿入');
}

function updateFPS(){
  S.fps = +document.getElementById('fps-input').value || 12;
}
// ===========================================================
// 再生
// ===========================================================
function togglePlay() {
  if (S.playing) {
    stopPlay();
  } else {
    // ★★★ これが決め手：再生開始前に現在のフレームを完全に同期 ★★★
    // これで startPlay() が呼ばれる時点で S.frame が最新になる
    goToFrame(S.frame);   // ← これを必ず最初に呼ぶ
    startPlay();
  }
}
function startPlay() {
  if (S.playing) return;

  goToFrame(S.frame);  // フレームを確実に同期

  S.playing = true;
  document.getElementById('play-btn').classList.add('active');
  document.getElementById('play-btn').textContent = '⏸';

  if (audioBuffer && audioContext) {
    // コンテキストがsuspendされてる場合、強制resume
    if (audioContext.state === 'suspended') {
      audioContext.resume().catch(e => console.warn("resume失敗:", e));
    }

    // 既存ソースをクリーンアップ
    if (audioSource) {
      try { audioSource.stop(); } catch (e) {}
      audioSource = null;
    }

    audioSource = audioContext.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioGainNode);
    audioSource.loop = false;

    const fps = S.fps || 24;
    const startFrame = Number(audioState.startFrame || 0);
    const currentFrame = S.frame;
    let relativeFrame = currentFrame - startFrame;

    let startTime = 0;
    if (relativeFrame > 0) {
      startTime = relativeFrame / fps;
    }

    // ── 先頭無音検出（安全に制限） ────────────────────────────────
    let realStartSec = 0;
    const silenceThreshold = 0.04;
    const maxSkipSec = 0.5;  // ← 最大0.5秒までしかスキップしない（安全）
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    let silentCount = 0;
    const maxSilentSamples = Math.min(sampleRate * maxSkipSec, channelData.length);

    for (let i = 0; i < channelData.length; i++) {
      if (Math.abs(channelData[i]) <= silenceThreshold) {
        silentCount++;
        if (silentCount >= sampleRate * 0.05) {  // 50ms連続
          realStartSec = i / sampleRate;
          if (realStartSec > maxSkipSec) {
            realStartSec = maxSkipSec;  // 上限
          }
          break;
        }
      } else {
        silentCount = 0;
      }
    }

    console.log(`無音検出結果: ${realStartSec.toFixed(3)}秒 (上限${maxSkipSec}秒)`);

    // ── 開始時間計算 ────────────────────────────────────────────────
    startTime += realStartSec;
    startTime = Math.max(0, startTime);  // 負にならない

    // 音声の長さを超えないようにクランプ（これが重要！）
    const maxStartTime = audioBuffer.duration - 0.01;  // 最後0.01秒残す
    if (startTime > maxStartTime) {
      startTime = maxStartTime;
      console.warn(`startTimeが長すぎたのでクランプ: ${startTime.toFixed(3)}秒`);
    }

    console.log(`最終再生開始位置: フレーム${currentFrame + 1} → 音声内 ${startTime.toFixed(3)}秒`);

    try {
      audioSource.start(audioContext.currentTime, startTime);
      console.log("audioSource.start 成功");
    } catch (err) {
      console.error("audioSource.start 失敗:", err);
    }
  } else {
    console.log("音声再生スキップ: audioBuffer or audioContext がない");
  }

  lastFrameTime = 0;
  accumulatedTime = 0;
  S.playTimer = requestAnimationFrame(playNext);
}

function stopPlay() {
  S.playing = false;
  document.getElementById('play-btn').classList.remove('active');
  document.getElementById('play-btn').textContent = '▶';

  if (S.playTimer) {
    cancelAnimationFrame(S.playTimer);
    S.playTimer = null;
  }

  if (audioSource) {
    try {
      audioSource.stop();
      audioSource.disconnect();
    } catch (e) {}
    audioSource = null;
  }

  lastFrameTime = 0;
  accumulatedTime = 0;

  // AudioContext を一時停止→再開して状態をクリア（これが効くことが多い）
  if (audioContext) {
    audioContext.suspend().then(() => {
      audioContext.resume();
    });
  }

  // 自動スクロールを止めるために現在の位置を維持（必要ならリセット）
  const scrollContainer = document.getElementById('tl-scroll-container');
  // scrollContainer.scrollTo({ left: 0, behavior: 'smooth' }); // 最初に戻す場合
}

let lastFrameTime = 0;
let accumulatedTime = 0;

function playNext(timestamp) {
  if (!S.playing) return;

  // ★ 追加：毎フレーム開始時に現在のフレームを確実に使う
  const currentFrame = S.frame;

  if (!lastFrameTime) lastFrameTime = timestamp;
  const deltaTime = timestamp - lastFrameTime;
  lastFrameTime = timestamp;

  accumulatedTime += deltaTime;

  const frameInterval = 1000 / S.fps;

  while (accumulatedTime >= frameInterval) {
    let skip = 1;
    for (let li = 0; li < LAYER_DEFS.length; li++) {
      const d = CFD()[li + '-' + currentFrame] || 1; // ← currentFrameを使う
      if (d > skip) skip = d;
    }

    let nf = currentFrame + skip;
    const totalFrames = CTF();

    if (nf >= totalFrames) {
      nf = 0;
    }

    goToFrame(nf);

    accumulatedTime -= frameInterval;

    if (accumulatedTime > frameInterval * 5) {
      accumulatedTime = frameInterval;
    }
  }
// ★★★ ここに自動スクロールを追加 ★★★
  if (S.playing) {
    autoScrollTimeline();
  }
  S.playTimer = requestAnimationFrame(playNext);
}

function autoScrollTimeline() {
  const scrollContainer = document.getElementById('tl-right-scrollable');
  if (!scrollContainer) return;

  const cellWidth = 28;
  const headX = S.frame * cellWidth;

  const viewportWidth = scrollContainer.clientWidth;
  const targetRatio = 0.38;  // ← ここはお好み（0.3〜0.45が安定しやすい）
  const targetOffset = viewportWidth * targetRatio;

  const targetScrollLeft = Math.max(0, headX - targetOffset);

  // smooth を完全に外す → 即時移動
  scrollContainer.scrollLeft = targetScrollLeft;

  // デバッグ用（後で消してもOK）
  console.log(`[Scroll] frame=${S.frame} → scrollLeft=${targetScrollLeft}`);
}
// ===========================================================
// 自動中割
// ===========================================================
function showInbetweenDialog(){document.getElementById('inb-start').value=S.frame+1;document.getElementById('inb-end').value=Math.min(S.frame+2,CTF());document.getElementById('inb-count').value=3;document.getElementById('inbetween-dialog').classList.add('show');}
function generateInbetweens() {
  const sf = +document.getElementById('inb-start').value - 1;
  const ef = +document.getElementById('inb-end').value - 1;
  const cnt = +document.getElementById('inb-count').value;
  const ease = document.getElementById('inb-easing').value;

  if (sf < 0 || ef >= CTF() || sf >= ef || cnt < 1) {
    notify('フレーム範囲または枚数が不正です');
    return;
  }

  pushUndo();

  const targetLayer = S.layer;
  const sS = CF()[targetLayer].frames[sf].strokes;
  const eS = CF()[targetLayer].frames[ef].strokes;

  let insertPos = sf + 1;

  for (let i = 0; i < cnt; i++) {
    const t = (i + 1) / (cnt + 1);
    const interp = interpStrokes(sS, eS, t, ease);
    
    // 補間後スムージング
    const smoothed = smoothInterpolatedStrokes(interp);

    // ★ すべてのレイヤーのストロークを収集して吸着
    const existing = [];
    CF().forEach(layer => {
      if(layer.frames[sf] && layer.frames[sf].strokes){
        existing.push(...layer.frames[sf].strokes);
      }
      if(layer.frames[ef] && layer.frames[ef].strokes){
        existing.push(...layer.frames[ef].strokes);
      }
    });

    const finalStroke = snapNewStrokeToExisting(
      smoothed,
      existing,
      snapDistance,         // ← メインの値を使う
      snapFullStroke        // 全体吸着もメインの設定に従う
    );

    CF()[targetLayer].frames.splice(insertPos, 0, {
      strokes: finalStroke,
      draftImg: null
    });
    insertPos++;
  }

  closeModal('inbetween-dialog');
  updateTimeline();
  goToFrame(sf + 1);
  renderAll();
}
function interpStrokes(sa,sb,t,ease){const et=applyEase(t,ease);const r=[];const mx=Math.max(sa.length,sb.length);for(let i=0;i<mx;i++){const a=i<sa.length?sa[i]:null,b=i<sb.length?sb[i]:null;if(a&&b&&a.type===b.type)r.push(interpOne(a,b,et));else if(a&&!b)r.push(fadeS(a,1-et));else if(!a&&b)r.push(fadeS(b,et));else if(a&&b){et<0.5?r.push(fadeS(a,1-et*2)):r.push(fadeS(b,(et-0.5)*2));}}return r;}

// ★ 新規追加：補間後のストロークをスムージング処理
function smoothInterpolatedStrokes(strokes) {
  const result = [];
  
  for (const stroke of strokes) {
    if (stroke.type === 'bezier' && stroke.controls && stroke.controls.length > 2) {
      // ベジェ曲線の場合のみスムージングを適用
      const smoothedStroke = {
        ...stroke,
        controls: smoothBezierControls(stroke.controls)
      };
      result.push(smoothedStroke);
    } else {
      // それ以外のストロークはそのまま
      result.push(stroke);
    }
  }
  
  return result;
}

// Catmull-Romスプライン補間を使用してコントロールポイントを滑らかにする
function smoothBezierControls(controls) {
  if (controls.length <= 2) return controls;
  
  // まず全ポイントを抽出（始点と終点のみ）
  const points = [];
  points.push({ x: controls[0].sx, y: controls[0].sy });
  for (const ctrl of controls) {
    points.push({ x: ctrl.ex, y: ctrl.ey });
  }
  
  // ポイント数が少ない場合はそのまま返す
  if (points.length <= 3) return controls;
  
  // ポイントを間引いて最適化（距離が近すぎるポイントを削除）
  const optimized = optimizePoints(points);
  
  // 最適化されたポイントから新しいコントロールポイントを生成
  const newControls = [];
  
  for (let i = 0; i < optimized.length - 1; i++) {
    const p0 = i > 0 ? optimized[i - 1] : optimized[i];
    const p1 = optimized[i];
    const p2 = optimized[i + 1];
    const p3 = i < optimized.length - 2 ? optimized[i + 2] : optimized[i + 1];
    
    // Catmull-Romスプラインの制御点を計算
    const tension = 0.5; // 張力パラメータ（0.5が標準）
    
    const cx = p1.x + (p2.x - p0.x) * tension / 6;
    const cy = p1.y + (p2.y - p0.y) * tension / 6;
    
    newControls.push({
      sx: p1.x,
      sy: p1.y,
      cx: cx,
      cy: cy,
      ex: p2.x,
      ey: p2.y
    });
  }
  
  return newControls.length > 0 ? newControls : controls;
}

// ポイントを最適化（近すぎるポイントを削除）
function optimizePoints(points) {
  if (points.length <= 3) return points;
  
  const optimized = [points[0]]; // 最初の点は必ず含める
  const minDistance = 3; // 最小距離の閾値
  
  for (let i = 1; i < points.length - 1; i++) {
    const prev = optimized[optimized.length - 1];
    const curr = points[i];
    
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // 距離が閾値以上の場合のみ追加
    if (dist >= minDistance) {
      optimized.push(curr);
    }
  }
  
  // 最後の点は必ず含める
  optimized.push(points[points.length - 1]);
  
  return optimized;
}

// ★ 新規追加：ストローク端点の吸着機能
function snapStrokeEndpoints(strokes, snapDistance = 3) {
  if (strokes.length === 0) return strokes;
  
  const result = JSON.parse(JSON.stringify(strokes)); // ディープコピー
  
  // 全ストロークの端点を収集
  const endpoints = [];
  for (let i = 0; i < result.length; i++) {
    const stroke = result[i];
    if (stroke.type === 'bezier' && stroke.controls && stroke.controls.length > 0) {
      const first = stroke.controls[0];
      const last = stroke.controls[stroke.controls.length - 1];
      endpoints.push({
        strokeIdx: i,
        isStart: true,
        x: first.sx,
        y: first.sy
      });
      endpoints.push({
        strokeIdx: i,
        isStart: false,
        x: last.ex,
        y: last.ey
      });
    } else if (stroke.type === 'line') {
      endpoints.push({
        strokeIdx: i,
        isStart: true,
        x: stroke.x1,
        y: stroke.y1
      });
      endpoints.push({
        strokeIdx: i,
        isStart: false,
        x: stroke.x2,
        y: stroke.y2
      });
    }
  }
  
  // 各端点について、近くの端点を探して吸着
  for (let i = 0; i < endpoints.length; i++) {
    const ep1 = endpoints[i];
    
    for (let j = i + 1; j < endpoints.length; j++) {
      const ep2 = endpoints[j];
      
      // 同じストロークの両端点は吸着しない
      if (ep1.strokeIdx === ep2.strokeIdx) continue;
      
      const dx = ep2.x - ep1.x;
      const dy = ep2.y - ep1.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      // 距離が閾値以内なら吸着
      if (dist > 0 && dist <= snapDistance) {
        // 中間点に吸着
        const snapX = (ep1.x + ep2.x) / 2;
        const snapY = (ep1.y + ep2.y) / 2;
        
        // ep1を更新
        updateEndpoint(result[ep1.strokeIdx], ep1.isStart, snapX, snapY);
        endpoints[i].x = snapX;
        endpoints[i].y = snapY;
        
        // ep2を更新
        updateEndpoint(result[ep2.strokeIdx], ep2.isStart, snapX, snapY);
        endpoints[j].x = snapX;
        endpoints[j].y = snapY;
      }
    }
  }
  
  return result;
}

// ストロークの端点を更新
function updateEndpoint(stroke, isStart, x, y) {
  if (stroke.type === 'bezier' && stroke.controls && stroke.controls.length > 0) {
    if (isStart) {
      stroke.controls[0].sx = x;
      stroke.controls[0].sy = y;
    } else {
      const last = stroke.controls[stroke.controls.length - 1];
      last.ex = x;
      last.ey = y;
    }
  } else if (stroke.type === 'line') {
    if (isStart) {
      stroke.x1 = x;
      stroke.y1 = y;
    } else {
      stroke.x2 = x;
      stroke.y2 = y;
    }
  }
}

// ★ 新規追加：新しいストロークを既存ストロークに吸着
function snapNewStrokeToExisting(newStroke, existingStrokes, snapDistance = 3) {
  //デバッグ
  console.log("[snapNewStrokeToExisting] 呼び出し元:", new Error().stack.split("\n")[2]);
console.log("[snapNewStrokeToExisting] snapFullStroke =", snapFullStroke);
//デバッグここまで

  const result = JSON.parse(JSON.stringify(newStroke)); // ディープコピー

  // 新しいストロークの始点と終点を取得
  let startPoint = null;
  let endPoint = null;

  if (result.type === 'bezier' && result.controls && result.controls.length > 0) {
    const first = result.controls[0];
    const last = result.controls[result.controls.length - 1];
    startPoint = { x: first.sx, y: first.sy };
    endPoint = { x: last.ex, y: last.ey };
  } else if (result.type === 'line') {
    startPoint = { x: result.x1, y: result.y1 };
    endPoint = { x: result.x2, y: result.y2 };
  }

  if (!startPoint || !endPoint) return result;

  // ── 吸着候補点の収集 ────────────────────────────────
  const candidates = [];

  for (let i = 0; i < existingStrokes.length; i++) {
    const s = existingStrokes[i];
    if (s === newStroke) continue; // 自分自身は除外

    if (snapFullStroke) {
      // 全体吸着：パスを細かくサンプリング
      let pathPts = [];
      if (s.type === 'bezier' && s.controls && s.controls.length > 0) {
        for (const c of s.controls) {
          for (let t = 0; t <= 1; t += 0.05) {
            const u = 1 - t;
            const x = u*u*c.sx + 2*u*t*c.cx + t*t*c.ex;
            const y = u*u*c.sy + 2*u*t*c.cy + t*t*c.ey;
            pathPts.push({x, y});
          }
        }
      } else if (s.type === 'line') {
        for (let t = 0; t <= 1; t += 0.05) {
          pathPts.push({
            x: s.x1 + (s.x2 - s.x1) * t,
            y: s.y1 + (s.y2 - s.y1) * t
          });
        }
      }

      // サンプリングした全点から最も近い点を探す
      for (const pt of pathPts) {
        candidates.push({x: pt.x, y: pt.y, distToStart: Math.hypot(pt.x - startPoint.x, pt.y - startPoint.y)});
        candidates.push({x: pt.x, y: pt.y, distToEnd: Math.hypot(pt.x - endPoint.x, pt.y - endPoint.y)});
      }
    } else {
      // 従来の端点のみ吸着
      if (s.type === 'bezier' && s.controls && s.controls.length > 0) {
        candidates.push({x: s.controls[0].sx, y: s.controls[0].sy});
        candidates.push({x: s.controls[s.controls.length-1].ex, y: s.controls[s.controls.length-1].ey});
      } else if (s.type === 'line') {
        candidates.push({x: s.x1, y: s.y1});
        candidates.push({x: s.x2, y: s.y2});
      }
    }
  }

  // ── 始点の吸着 ────────────────────────────────
  let bestStart = null;
  let minDistStart = snapDistance + 1;

  for (const cand of candidates) {
    const d = Math.hypot(cand.x - startPoint.x, cand.y - startPoint.y);
    if (d < minDistStart && d > 0) {
      minDistStart = d;
      bestStart = cand;
    }
  }

  // ── 終点の吸着 ────────────────────────────────
  let bestEnd = null;
  let minDistEnd = snapDistance + 1;

  for (const cand of candidates) {
    const d = Math.hypot(cand.x - endPoint.x, cand.y - endPoint.y);
    if (d < minDistEnd && d > 0) {
      minDistEnd = d;
      bestEnd = cand;
    }
  }

  // ── 適用 ────────────────────────────────
  if (bestStart && minDistStart <= snapDistance) {
    updateEndpoint(result, true, bestStart.x, bestStart.y);
  }
  if (bestEnd && minDistEnd <= snapDistance) {
    updateEndpoint(result, false, bestEnd.x, bestEnd.y);
  }

  return result;
}
function interpOne(a,b,t){
  if(a.type==='bezier'&&b.type==='bezier')return{type:'bezier',controls:interpBezier(a.controls,b.controls,t),color:lerpCol(a.color,b.color,t),size:lerp(a.size,b.size,t),order:a.order};
  if(a.type==='line'&&b.type==='line')return{type:'line',x1:lerp(a.x1,b.x1,t),y1:lerp(a.y1,b.y1,t),x2:lerp(a.x2,b.x2,t),y2:lerp(a.y2,b.y2,t),color:lerpCol(a.color,b.color,t),size:lerp(a.size,b.size,t),order:a.order};
  if(a.type==='ellipse'&&b.type==='ellipse')return{type:'ellipse',cx:lerp(a.cx,b.cx,t),cy:lerp(a.cy,b.cy,t),rx:lerp(a.rx,b.rx,t),ry:lerp(a.ry,b.ry,t),color:lerpCol(a.color,b.color,t),size:lerp(a.size,b.size,t),order:a.order};
  if(a.type==='rect'&&b.type==='rect')return{type:'rect',x:lerp(a.x,b.x,t),y:lerp(a.y,b.y,t),w:lerp(a.w,b.w,t),h:lerp(a.h,b.h,t),color:lerpCol(a.color,b.color,t),size:lerp(a.size,b.size,t),order:a.order};return a;
}
function interpBezier(ca,cb,t){const ml=Math.max(ca.length,cb.length);const ra=resampleCtrl(ca,ml),rb=resampleCtrl(cb,ml);return ra.map((a,i)=>{const b=rb[i];return{sx:lerp(a.sx,b.sx,t),sy:lerp(a.sy,b.sy,t),cx:lerp(a.cx,b.cx,t),cy:lerp(a.cy,b.cy,t),ex:lerp(a.ex,b.ex,t),ey:lerp(a.ey,b.ey,t)};});}
function resampleCtrl(c,n){if(c.length===n)return c;if(c.length===0)return Array(n).fill({sx:0,sy:0,cx:0,cy:0,ex:0,ey:0});const r=[];for(let i=0;i<n;i++){const si=(i/(n-1||1))*(c.length-1);const lo=Math.floor(si),hi=Math.min(lo+1,c.length-1),f=si-lo;const a=c[lo],b=c[hi];r.push({sx:lerp(a.sx,b.sx,f),sy:lerp(a.sy,b.sy,f),cx:lerp(a.cx,b.cx,f),cy:lerp(a.cy,b.cy,f),ex:lerp(a.ex,b.ex,f),ey:lerp(a.ey,b.ey,f)});}return r;}
function fadeS(s,a){const r=JSON.parse(JSON.stringify(s));if(r.color){const rgb=hex2rgb(r.color);if(rgb)r.color=`rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;}return r;}
function lerp(a,b,t){return a+(b-a)*t;}
function lerpCol(a,b,t){const c1=hex2rgb(a)||{r:0,g:0,b:0},c2=hex2rgb(b)||{r:0,g:0,b:0};return`rgb(${Math.round(lerp(c1.r,c2.r,t))},${Math.round(lerp(c1.g,c2.g,t))},${Math.round(lerp(c1.b,c2.b,t))})`;}
function hex2rgb(h){if(!h)return null;if(h.startsWith('rgb')){const m=h.match(/(\d+)/g);return m?{r:+m[0],g:+m[1],b:+m[2]}:null;}const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);return r?{r:parseInt(r[1],16),g:parseInt(r[2],16),b:parseInt(r[3],16)}:null;}
function applyEase(t,ty){switch(ty){case'easeIn':return t*t;case'easeOut':return t*(2-t);case'easeInOut':return t<0.5?2*t*t:-1+(4-2*t)*t;default:return t;}}

// ===========================================================
// Undo/Redo
// ===========================================================
function pushUndo(){undoStack.push({cuts:JSON.parse(JSON.stringify(cuts)),cc:currentCut,f:S.frame,li:S.layer});if(undoStack.length>MAX_UNDO)undoStack.shift();redoStack=[];}
function undoAction(){if(!undoStack.length)return;redoStack.push({cuts:JSON.parse(JSON.stringify(cuts)),cc:currentCut,f:S.frame,li:S.layer});const s=undoStack.pop();cuts=s.cuts;currentCut=s.cc;S.frame=s.f;S.layer=s.li;updateCutList();updateLayerList();updateTimeline();renderAll();}
function redoAction(){if(!redoStack.length)return;undoStack.push({cuts:JSON.parse(JSON.stringify(cuts)),cc:currentCut,f:S.frame,li:S.layer});const s=redoStack.pop();cuts=s.cuts;currentCut=s.cc;S.frame=s.f;S.layer=s.li;updateCutList();updateLayerList();updateTimeline();renderAll();}

// ===========================================================
// 保存/読込
// ===========================================================
function getProjectName(){return document.getElementById('project-name-input').value.trim()||'untitled';}
function saveProject(){
  const pn=getProjectName();
  const p={version:2,appName:'StrokeAnimationStudio',projectName:pn,cw:S.cw,ch:S.ch,fps:S.fps,cuts,currentCut,frame:S.frame,layer:S.layer,layerVis,onionLayerVis,
    frameGuide:{w:frameGuideW,h:frameGuideH,enabled:document.getElementById('frame-guide-enabled').checked},
    popupImages:project.popupImages||[],
  audio: audioState  };
  const b=new Blob([JSON.stringify(p)],{type:'application/json'});
  const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download=pn+'.sasp';a.click();URL.revokeObjectURL(a.href);notify('保存: '+pn+'.sasp');
}
function loadProject(){document.getElementById('file-input-project').click();}
function handleLoadProject(e){
  const f = e.target.files[0];
  if (!f) return;
  const rd = new FileReader();
  rd.onload = async ev => {
    try {
      const p = JSON.parse(ev.target.result);if(p.appName!=='StrokeAnimationStudio'){notify('不正なファイル');return;}
    S.cw=p.cw;S.ch=p.ch;S.fps=p.fps;
    if(p.version>=2){cuts=p.cuts;currentCut=p.currentCut||0;}else{cuts=[{name:'C_001',totalFrames:p.totalFrames,frameDur:p.frameDur||{},layers:p.layers}];currentCut=0;}
    S.frame=p.frame||0;S.layer=p.layer||0;layerVis=p.layerVis||{};
    // 音声データの読み込み
      if (p.audio) {
        audioState = p.audio;
        if (audioState.file) {
          await initAudioContext();
          updateAudioInfo();
        }
      }
    // オニオンレイヤー表示設定の読み込み
    if(p.onionLayerVis){onionLayerVis=p.onionLayerVis;}else{for(let i=0;i<LAYER_DEFS.length;i++)onionLayerVis[i]=true;}
    if(p.projectName)document.getElementById('project-name-input').value=p.projectName;
    document.getElementById('fps-input').value=S.fps;document.getElementById('info-width').value=S.cw;document.getElementById('info-height').value=S.ch;
    if(p.frameGuide){
      frameGuideW=p.frameGuide.w||1920;frameGuideH=p.frameGuide.h||1080;
      document.getElementById('frame-guide-w').value=frameGuideW;
      document.getElementById('frame-guide-h').value=frameGuideH;
      document.getElementById('frame-guide-enabled').checked=!!p.frameGuide.enabled;
    }
    // ★ popupImagesの読み込み
    if(p.popupImages){
      project.popupImages=p.popupImages;
      // localStorageにも同期
      const key=`project:${currentProjectId}:images`;
      localStorage.setItem(key,JSON.stringify(p.popupImages));
    }
    draftImgCache={};createCanvases();centerCanvas();updateCutList();updateLayerList();updateTimeline();
    renderAll();undoStack=[];redoStack=[];notify('読み込みました');
  } catch (err) {
      notify('エラー: ' + err.message);
    }
  };
  rd.readAsText(f);
  e.target.value = '';
}

// ===========================================================
// 新規/キャンバス/下書き
// ===========================================================
function newProject(){
  if(!confirm('現在の作業を破棄して新規作成しますか？'))return;
  S.cw=2600;S.ch=1500;S.fps=24;S.frame=0;S.layer=0;cuts=[createEmptyCut('C_001',24)];currentCut=0;
  for(let i=0;i<LAYER_DEFS.length;i++){layerVis[i]=true;onionLayerVis[i]=true;}
  undoStack=[];redoStack=[];draftImgCache={};
  document.getElementById('project-name-input').value='untitled';document.getElementById('fps-input').value=S.fps;
  document.getElementById('info-width').value=S.cw;document.getElementById('info-height').value=S.ch;
  frameGuideW=1920;frameGuideH=1080;
  document.getElementById('frame-guide-w').value=1920;document.getElementById('frame-guide-h').value=1080;
  document.getElementById('frame-guide-enabled').checked=true;
  createCanvases();centerCanvas();updateCutList();updateLayerList();updateTimeline();
  renderAll();notify('新規作成');
}
function showCanvasSizeDialog(){document.getElementById('canvas-w-input').value=S.cw;document.getElementById('canvas-h-input').value=S.ch;document.getElementById('canvas-size-modal').classList.add('show');}
function applyCanvasSize(){const w=+document.getElementById('canvas-w-input').value,h=+document.getElementById('canvas-h-input').value;if(w<1||h<1||w>8192||h>8192){notify('サイズが不正');return;}pushUndo();S.cw=w;S.ch=h;document.getElementById('info-width').value=w;document.getElementById('info-height').value=h;createCanvases();centerCanvas();renderAll();closeModal('canvas-size-modal');notify(`キャンバス: ${w}×${h}`);}
function applyProjectInfo(){
  const w=+document.getElementById('info-width').value,h=+document.getElementById('info-height').value;
  if(w<1||h<1||w>8192||h>8192){notify('サイズが不正');document.getElementById('info-width').value=S.cw;document.getElementById('info-height').value=S.ch;return;}
  pushUndo();S.cw=w;S.ch=h;createCanvases();centerCanvas();renderAll();notify(`キャンバス: ${w}×${h}`);
}
function applyProjectInfoFrames(){
  const nf=+document.getElementById('info-frames').value;
  if(nf<1||nf>9999){notify('フレーム数が不正');document.getElementById('info-frames').value=CTF();return;}
  pushUndo();
  const old=CTF();
  if(nf>old){
    for(let i=0;i<LAYER_DEFS.length;i++)for(let f=old;f<nf;f++)CF()[i].frames.push({strokes:[],draftImg:null});
  }else if(nf<old){
    for(let i=0;i<LAYER_DEFS.length;i++)CF()[i].frames.splice(nf);
  }
  CC().totalFrames=nf;
  if(S.frame>=nf)S.frame=nf-1;
  updateTimeline();renderAll();notify(`フレーム数: ${nf}`);
}
function closeModal(id){document.getElementById(id).classList.remove('show');}
function importDraftImage(){if(LAYER_DEFS[S.layer].type!=='draft'){notify('下書きレイヤーを選択してください');return;}document.getElementById('file-input-draft').click();}
function handleDraftImage(e){const f=e.target.files[0];if(!f)return;const rd=new FileReader();rd.onload=ev=>{pushUndo();const dataUrl=ev.target.result;CF()[S.layer].frames[S.frame].draftImg=dataUrl;const img=new Image();img.onload=()=>{const key=currentCut+'-'+S.layer+'-'+S.frame;draftImgCache[key]=img;renderAll();notify('下書き読み込み');};img.src=dataUrl;};rd.readAsDataURL(f);e.target.value='';}

// ===========================================================
// 連番PNG出力（Starlit Timeline Editor互換方式）
// ===========================================================

async function exportAllPNG(){
  const prog=document.getElementById('export-progress');
  const fill=document.getElementById('export-progress-fill');
  const text=document.getElementById('export-progress-text');
  prog.style.display='block';fill.style.width='0%';

  const zip=new JSZip();const pn=getProjectName();
  let totalCount=0;for(const c of cuts)totalCount+=c.totalFrames;
  let done=0;

  const offscreen=document.createElement('canvas');offscreen.width=S.cw;offscreen.height=S.ch;
  const offCtx=offscreen.getContext('2d');offCtx.imageSmoothingEnabled=false;
  const layerOff=document.createElement('canvas');layerOff.width=S.cw;layerOff.height=S.ch;
  const layerOffCtx=layerOff.getContext('2d');layerOffCtx.imageSmoothingEnabled=false;

  for(let ci=0;ci<cuts.length;ci++){
    const cut=cuts[ci];const cutNum=String(ci+1).padStart(3,'0');
    const cutName='C-'+cutNum;
    const folder=zip.folder(pn+'_'+cutName);
    for(let fi=0;fi<cut.totalFrames;fi++){
      offCtx.clearRect(0,0,S.cw,S.ch);
      // ★修正：レイヤーを逆順で描画（下から上へ：4,3,2,1 → 結果として1が最上位）
      for(let li=LAYER_DEFS.length-1;li>=0;li--){
        if(!layerVis[li])continue;layerOffCtx.clearRect(0,0,S.cw,S.ch);
        const isDraft=LAYER_DEFS[li].type==='draft';
        // 持続フレーム対応
        const dur=cut.frameDur||{};
        let eidx=fi;
        for(let f=fi;f>=0;f--){const d=dur[li+'-'+f]||1;if(d>1&&fi>=f&&fi<=f+d-1){eidx=f;break;}}
        const fr=cut.layers[li].frames[eidx];if(!fr)continue;
        if(fr.draftImg){await new Promise(res=>{const img=new Image();img.onload=()=>{layerOffCtx.drawImage(img,0,0,S.cw,S.ch);res();};img.src=fr.draftImg;});}
        drawStrokes(layerOffCtx,fr.strokes);if(!isDraft)binarizeCanvas(layerOffCtx,S.cw,S.ch);
        if(isDraft){offCtx.globalAlpha=draftOpacity;offCtx.drawImage(layerOff,0,0);offCtx.globalAlpha=1;}
        else{offCtx.drawImage(layerOff,0,0);}
      }
      const frameNum=String(fi).padStart(4,'0');
      const filename=cutName+'_'+frameNum+'.png';
      const dataUrl=offscreen.toDataURL('image/png');
      const base64Data=dataUrl.split(',')[1];
      folder.file(filename,base64Data,{base64:true});
      done++;fill.style.width=Math.round(done/totalCount*100)+'%';text.textContent=`${done} / ${totalCount}`;
      if(done%4===0)await new Promise(r=>setTimeout(r,10));
    }
  }
  text.textContent='ZIP圧縮中...';
  const blob=await zip.generateAsync({type:'blob'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download=pn+'_png.zip';
  a.click();
  URL.revokeObjectURL(a.href);
  prog.style.display='none';notify(`${totalCount}枚のPNGをZIP出力`);
}
// ===========================================================
function notify(msg){const el=document.getElementById('notification');el.textContent=msg;el.style.display='block';clearTimeout(el._t);el._t=setTimeout(()=>{el.style.display='none';},2500);}
window.addEventListener('load',init);

const popup = document.getElementById('floatingPopup');
const popupHeader = document.getElementById('popupHeader');
const handle = document.getElementById('resizeHandle');

let drag = false;
let resizing = false;

let ox=0, oy=0;
let startX=0, startY=0, startW=0, startH=0;

popupHeader.addEventListener('mousedown', e=>{
  drag = true;

  popup.style.left = popup.offsetLeft + 'px';
  popup.style.right = 'auto';

  ox = e.clientX - popup.offsetLeft;
  oy = e.clientY - popup.offsetTop;
});

handle.addEventListener('mousedown', e=>{
  e.stopPropagation();   // ← 超重要
  resizing = true;

  startX = e.clientX;
  startY = e.clientY;
  startW = popup.offsetWidth;
  startH = popup.offsetHeight;
});

document.addEventListener('mousemove', e=>{
  if(drag){
    popup.style.left = (e.clientX - ox) + 'px';
    popup.style.top  = (e.clientY - oy) + 'px';
  }

  if(resizing){
    const w = startW + (e.clientX - startX);
    const h = startH + (e.clientY - startY);

    popup.style.width  = Math.max(160, w) + 'px';
    popup.style.height = Math.max(120, h) + 'px';
  }
});

document.addEventListener('mouseup', ()=>{
  drag = false;
  resizing = false;
});


let imageData = null;

// プロジェクトID
const currentProjectId = 'project_001';

imgInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    const base64 = reader.result;
    const key = `project:${currentProjectId}:images`;
    const images = JSON.parse(localStorage.getItem(key)) || [];
    
    // localStorageに追加
    images.push(reader.result);
    localStorage.setItem(key, JSON.stringify(images));

    // ★ popup が表示中なら必ず更新
    if (floatingPopup.offsetParent !== null) {
      popupFrame.contentWindow.postMessage({
        type: 'imageAdded'
      }, '*');
    }

    // ★★★ ここで.saspファイル(project)に画像を埋め込む ★★★
    // プロジェクトデータに画像配列を保持
    if (!project.popupImages) {
      project.popupImages = [];
    }
    project.popupImages.push(base64);
    
    notify('画像を読み込みました');
    console.log('画像をプロジェクトに追加:', base64.slice(0, 40));
  };
  reader.readAsDataURL(file);
});


openPopup.addEventListener('click', () => {
  floatingPopup.style.display = 'block';

  // ★ imageData は見ない。常に再読み込み
  popupFrame.src =
    `popup.html?project=${currentProjectId}&t=${Date.now()}`;
});

// ========================================================================
// ★ popup.html からの各種メッセージを受信
// ========================================================================
window.addEventListener('message', (event) => {
  // 安全のため、信頼できるオリジンからのメッセージだけ処理（同じドメインなら省略可）
  // if (event.origin !== window.location.origin) return;

  const data = event.data;

  // ── 1. 画像ライブラリ更新の通知（今までの処理） ──
  if (data.type === 'updatePopupImages') {
    const { images, projectId } = data;
    
    // projectオブジェクトを更新
    project.popupImages = images;
    
    // localStorage にも同期（必要なら）
    const key = `project:${projectId}:images`;
    localStorage.setItem(key, JSON.stringify(images));
    
    notify('画像ライブラリを更新しました');
  }

  // ── 2. 新規：スポイト開始のリクエスト ──
  else if (data.type === 'requestEyedropper') {
    startEyedropperMode();
  }

  // 必要なら他にも拡張可能
  // else if (data.type === '何か別のメッセージ') { ... }
});

// ページ読み込み後 or init() の最後あたりに追加
function initColorPalette() {
  const palette = document.getElementById('color-palette');
  if (!palette) return;

  const buttons = palette.querySelectorAll('.color-swatch');

  // 初期状態：現在のペン色に一致するものをアクティブに
  updateActiveColorButton();

  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      const newColor = btn.dataset.color;
      S.penColor = newColor;
      document.getElementById('pen-color').value = newColor;

      // アクティブ状態の切り替え
      buttons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      notify(`色を ${newColor} に変更しました`);
    });
  });
}

// 色が変わったとき・ツールが変わったときなどに呼び出す
function updateActiveColorButton() {
  const buttons = document.querySelectorAll('#color-palette #color-palette2 .color-swatch');
  buttons.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.color.toLowerCase() === S.penColor.toLowerCase());
  });
}

// 既存の色変更箇所（pen-color の input イベントなど）にも追加
document.getElementById('pen-color').addEventListener('input', e => {
  S.penColor = e.target.value;
  updateActiveColorButton();   // ← 追加
});

// init() の最後に呼び出し
initColorPalette();

// JavaScript部分の追加 (連番読み込み関数を追加)

// 連番画像読み込みダイアログを開く
function importSequenceImages(){
  document.getElementById('file-input-sequence').click();
}

// 連番画像を処理（修正版）
function handleSequenceImages(e){
  const files=Array.from(e.target.files);
  if(!files.length)return;
  
  console.log('選択されたファイル数:', files.length); // デバッグ用
  
  // ファイル名でソート(数字部分を考慮)
  files.sort((a,b)=>{
    const numA=extractNumber(a.name);
    const numB=extractNumber(b.name);
    if(numA!==numB)return numA-numB;
    return a.name.localeCompare(b.name); // 数字が同じ場合は名前順
  });
  
  notify(`${files.length}枚の画像を読み込み中...`);
  
  const startFrame=S.frame;
  const targetLayer=S.layer;
  
  // フレーム数が足りない場合は追加
  const neededFrames=startFrame+files.length;
  if(neededFrames>CTF()){
    const diff=neededFrames-CTF();
    for(let i=0;i<diff;i++){
      for(let li=0;li<LAYER_DEFS.length;li++){
        CF()[li].frames.push({strokes:[],draftImg:null});
      }
    }
    CC().totalFrames=neededFrames;
  }
  
  pushUndo();
  
  let loadedCount=0;
  const totalFiles=files.length;
  
  // 各画像を順次読み込み
  files.forEach((file,idx)=>{
    const reader=new FileReader();
    
    reader.onerror=()=>{
      console.error('ファイル読み込みエラー:', file.name);
      loadedCount++;
      checkComplete();
    };
    
    reader.onload=ev=>{
      const dataUrl=ev.target.result;
      const frameIdx=startFrame+idx;
      
      console.log(`読み込み: ${file.name} → フレーム${frameIdx+1}`); // デバッグ用
      
      // 対象レイヤーの指定フレームに画像を設定
      if(frameIdx<CF()[targetLayer].frames.length){
        CF()[targetLayer].frames[frameIdx].draftImg=dataUrl;
        
        // キャッシュに登録
        const img=new Image();
        img.onload=()=>{
          const key=currentCut+'-'+targetLayer+'-'+frameIdx;
          draftImgCache[key]=img;
          loadedCount++;
          checkComplete();
        };
        img.onerror=()=>{
          console.error('画像デコードエラー:', file.name);
          loadedCount++;
          checkComplete();
        };
        img.src=dataUrl;
      }else{
        console.error('フレームインデックスが範囲外:', frameIdx);
        loadedCount++;
        checkComplete();
      }
    };
    
    reader.readAsDataURL(file);
  });
  
  function checkComplete(){
    console.log(`進行状況: ${loadedCount}/${totalFiles}`); // デバッグ用
    if(loadedCount===totalFiles){
      updateTimeline();
      renderAll();
      notify(`${totalFiles}枚の連番画像を読み込みました`);
      goToFrame(startFrame);
    }
  }
  
  e.target.value='';
}

// ファイル名から数字を抽出(連番判定用)
function extractNumber(filename){
  // ファイル名から数字部分を抽出（拡張子を除く）
  const nameWithoutExt=filename.replace(/\.[^.]+$/,'');
  const match=nameWithoutExt.match(/\d+/g);
  if(!match||match.length===0)return 0;
  // 最後の数字グループを使用（通常は連番部分）
  return parseInt(match[match.length-1],10);
}

function importAudioFile() {
  document.getElementById('file-input-audio').click();
}

function handleAudioFile(e) {
  const file = e.target.files[0];
  if (!file) return;

  audioState.originalFileName = file.name;   // ← 追加！これが大事

  const reader = new FileReader();
  reader.onload = async (ev) => {
    audioState.file = ev.target.result;
    audioState.startFrame = 0;

    await initAudioContext();

    notify('音声を読み込みました: ' + file.name);
    updateAudioInfo();
    updateAudioTimeline();   // ここでファイル名が反映される
  };
  reader.readAsDataURL(file);
  e.target.value = '';
}

async function initAudioContext() {
  if (!audioState.file) return;

  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    audioGainNode = audioContext.createGain();
    audioGainNode.connect(audioContext.destination);
  }

  // Base64からArrayBufferに変換
  const base64Data = audioState.file.split(',')[1];
  const binaryData = atob(base64Data);
  const arrayBuffer = new ArrayBuffer(binaryData.length);
  const view = new Uint8Array(arrayBuffer);
  for (let i = 0; i < binaryData.length; i++) {
    view[i] = binaryData.charCodeAt(i);
  }

  audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
  audioState.duration = audioBuffer.duration;

  // フレーム自動拡張
  const fps = S.fps || 24;
  const requiredFrames = Math.ceil(audioState.duration * fps) + 48;
  const currentTotal = CTF();
  if (requiredFrames > currentTotal) {
    const diff = requiredFrames - currentTotal;
    for (let i = 0; i < diff; i++) {
      for (let li = 0; li < LAYER_DEFS.length; li++) {
        CF()[li].frames.push({ strokes: [], draftImg: null });
      }
    }
    CC().totalFrames = requiredFrames;
    console.log("拡張後 totalFrames =", CC().totalFrames); // ← 追加：確認用
    notify(`音声長さ(${audioState.duration.toFixed(1)}秒)に合わせてフレーム数を ${requiredFrames} に自動拡張しました`);
  }
  // ★★★ ここを追加 ★★★
  updateTimeline();          // 横線・セル・ヘッダーを再生成
drawAudioWaveform();       // 波形も再描画
renderAll();               // キャンバス側も更新

// さらに強制的に現在のフレーム数を表示更新
document.getElementById('total-frame-display').textContent = CTF();
document.getElementById('info-frames').value = CTF();

  

  drawAudioWaveform();
  updateAudioTimeline();
}

function updateAudioVolume(val) {
  audioState.volume = +val;
  document.getElementById('audio-volume-val').textContent = val + '%';
  if (audioGainNode) {
    audioGainNode.gain.value = audioState.muted ? 0 : (audioState.volume / 100);
  }
}

function toggleAudioMute() {
  audioState.muted = !audioState.muted;
  const btn = document.getElementById('audio-mute-btn');
  btn.textContent = audioState.muted ? '🔇 ミュート解除' : '🔊 ミュート';
  if (audioGainNode) {
    audioGainNode.gain.value = audioState.muted ? 0 : (audioState.volume / 100);
  }
}

function deleteAudio() {
  if (!confirm('音声を削除しますか？')) return;
  audioState.file = null;
  audioBuffer = null;
  if (audioSource) {
    audioSource.stop();
    audioSource = null;
  }
  updateAudioInfo();
  updateAudioTimeline();
  notify('音声を削除しました');
}

// 音声読み込み成功時などに呼び出される関数を修正
function updateAudioInfo() {
  const filenameDisplay = document.getElementById('audio-filename-display');
  const durationDisplay  = document.getElementById('audio-duration-display');

  if (audioState.file) {
    // ファイル名だけ抜き出す（長いパスやDataURLを除去）
    let displayName = '音声ファイル';

    // DataURLの場合は「読み込んだ音声」などにするか、
    // 可能なら元のファイル名を保持しておくのが理想
    if (audioState.originalFileName) {
      displayName = audioState.originalFileName;
    } else if (audioState.file.startsWith('data:audio')) {
      displayName = '読み込んだ音声';
    }

    filenameDisplay.textContent = displayName;
    
    if (audioState.duration) {
      durationDisplay.textContent = `(${audioState.duration.toFixed(1)}秒)`;
    } else {
      durationDisplay.textContent = '';
    }
  } else {
    filenameDisplay.textContent = '音声なし';
    durationDisplay.textContent = '';
  }
}

function drawAudioWaveform() {
  const canvas = document.getElementById('audio-waveform-canvas');
  if (!canvas) {
    console.error("audio-waveform-canvas が見つかりません");
    return;
  }

  if (!audioBuffer) {
    canvas.width = 300;
    canvas.height = 24;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'var(--text-muted)';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('音声なし', canvas.width / 2, canvas.height / 2 + 3);
    return;
  }

  const fps = S.fps || 24;
  const cellWidth = 28;
  const sampleRate = audioBuffer.sampleRate;
  const channelData = audioBuffer.getChannelData(0);
  const duration = audioBuffer.duration || 1;

  // ── 先頭無音の検出（より厳しく、正確に） ────────────────────────
  let realStartSec = 0;
  const silenceThreshold = 0.04;      // ← ここを上げて無音判定を厳しく（0.025 → 0.04）
  const minSilenceSamples = sampleRate * 0.05;  // 最低50ms連続無音で確定
  let silentCount = 0;

  for (let i = 0; i < channelData.length; i++) {
    if (Math.abs(channelData[i]) <= silenceThreshold) {
      silentCount++;
      if (silentCount >= minSilenceSamples) {
        realStartSec = i / sampleRate;
        break;
      }
    } else {
      silentCount = 0;  // 音が出たらリセット
    }
  }

  // 検出できなかった場合は0（安全策）
  if (realStartSec === 0) {
    console.log("先頭無音検出できず → オフセット0秒");
  } else {
    console.log(`先頭無音検出: ${realStartSec.toFixed(3)}秒 ≈ ${Math.round(realStartSec * fps)}フレーム`);
  }

  // ── 無音分をスキップして有効部分だけ描画 ────────────────────────
  const effectiveDuration = duration - realStartSec;
  const totalPixels = Math.ceil(effectiveDuration * fps * cellWidth);

  canvas.width = Math.max(totalPixels, 300);
  canvas.height = 24;

  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 背景
  ctx.fillStyle = 'rgba(78, 205, 196, 0.03)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // ── 描画パラメータ ────────────────────────────────────────────────
  const threshold = 0.012;
  const minSilencePixels = 5;

  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';

  let isSpeaking = false;
  let lastDrawX = -1;

  // ── メインループ：無音をスキップして最初から描画 ────────────────
  for (let px = 0; px < canvas.width; px++) {
    // 時間計算：無音分を最初から飛ばす
    const time = px / (fps * cellWidth) + realStartSec;

    const startSample = Math.floor(time * sampleRate);
    const endSample = Math.min(
      Math.floor((time + 1 / (fps * cellWidth)) * sampleRate),
      channelData.length
    );

    let maxAmp = 0;
    for (let s = startSample; s < endSample && s < channelData.length; s++) {
      maxAmp = Math.max(maxAmp, Math.abs(channelData[s]));
    }

    const x = px;
    const y = canvas.height / 2;

    if (maxAmp > threshold) {
      if (!isSpeaking) {
        isSpeaking = true;
        lastDrawX = x;
      }
      if (lastDrawX >= 0) {
        ctx.beginPath();
        ctx.moveTo(lastDrawX, y);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
      lastDrawX = x;
    } else {
      if (isSpeaking) {
        if (lastDrawX >= 0) {
          ctx.beginPath();
          ctx.moveTo(lastDrawX, y);
          ctx.lineTo(x, y);
          ctx.stroke();
        }
        if (x - lastDrawX >= minSilencePixels) {
          lastDrawX = -1;
        }
      }
      isSpeaking = false;
    }
  }

  if (isSpeaking && lastDrawX >= 0) {
    ctx.beginPath();
    ctx.moveTo(lastDrawX, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  console.log(`波形描画完了: 幅 ${canvas.width}px (有効部分 ${effectiveDuration.toFixed(2)}秒)`);
}
function updateAudioOffset(val) {
  audioState.offsetSec = +val; // 新規プロパティ
  console.log("音声オフセット変更 →", audioState.offsetSec, "秒");
  // 必要なら即時再描画・再生位置更新
  drawAudioWaveform();
  updateAudioPlayhead();
}

// グローバル変数（どのレイヤーのパレットか覚えておく）
// 現在のレイヤー用ピッカー
let currentLayerForColorChange = -1;

// ポップアップ全体のラッパー（初回生成）
function createLayerPickerPopup() {
  // 既に存在していたら何もしない
  if (document.getElementById('layer-picker-popup')) return;

  // ポップアップ本体を作成
  const popup = document.createElement('div');
  popup.id = 'layer-picker-popup';
  popup.innerHTML = `
    <div class="picker-header">レイヤー色を変更</div>

    <!-- ミニカラーボタンエリア -->
    <div id="mini-color-buttons" style="display:flex; flex-wrap:wrap; gap:6px; justify-content:center; margin:12px 0 16px;">
      <!-- ここにJSでミニボタンが動的に入る -->
    </div>

    <!-- iro.js カラーピッカー -->
    <div style="text-align:center; margin:20px 0;">
      <div id="iro-picker-container" style="width:220px; height:220px; margin:0 auto;"></div>
    </div>
<div style="height: 40px;"></div>
    <!-- ★ スポイトボタン（ここが新規追加部分） ★ -->
    <div style="text-align:center; margin:10px 0 20px;">
      <button id="eyedropper-btn" title="画面全体から色を拾う（スポイト）"
        style="padding:10px 20px; background:#555; color:#fff; border:none; border-radius:8px; cursor:pointer; font-size:15px; font-weight:bold; transition:0.2s;">
        🎨 スポイトを使う
      </button>
    </div>

    <!-- 適用・閉じるボタン -->
    <div style="margin-top:16px; text-align:center;">
      <button id="apply-layer-color" 
        style="padding:10px 24px; background:var(--accent); color:#fff; border:none; border-radius:8px; cursor:pointer; font-weight:bold; margin-right:12px;">
        適用
      </button>
      <button id="close-layer-picker" 
        style="padding:10px 24px; background:var(--bg-input); color:var(--text-primary); border:1px solid var(--border); border-radius:8px; cursor:pointer;">
        閉じる
      </button>
    </div>
  `;

  document.body.appendChild(popup);

  // ── ミニカラーボタンを動的に生成 ───────────────────────────────
  generateMiniColorButtons();

  // ── iro.js ピッカーの初期化 ────────────────────────────────────
  const iroPicker = new iro.ColorPicker("#iro-picker-container", {
    width: 200,
    color: "#ffffff",           // 初期色（白）
    borderWidth: 1,
    borderColor: "#444",
    layout: [
      {
        component: iro.ui.Wheel,
        options: { wheelLightness: true }
      },
      {
        component: iro.ui.Slider,
        options: {
          sliderType: 'value',
          reverse: true           // 左＝黒、右＝白
        }
      },
      {
        component: iro.ui.Slider,
        options: { sliderType: 'saturation' }
      }
    ]
  });

  // ── 適用ボタン ──────────────────────────────────────────────────
  document.getElementById('apply-layer-color').onclick = () => {
    if (currentLayerForColorChange < 0) return;
    const hex = iroPicker.color.hexString;
    changeLayerLineColor(currentLayerForColorChange, hex);
    closeLayerPicker();
    notify(`レイヤー色を ${hex} に変更しました`);
  };

  // ── 閉じるボタン ────────────────────────────────────────────────
  document.getElementById('close-layer-picker').onclick = () => {
    closeLayerPicker();
  };

  // ── スポイトボタンの処理（ここがメイン！） ──────────────────────
  document.getElementById('eyedropper-btn').onclick = () => {
    if (currentLayerForColorChange < 0) {
      notify('レイヤーが選択されていません');
      return;
    }

    // ネイティブ EyeDropper API が使える場合
    if (window.EyeDropper) {
      const eyeDropper = new EyeDropper();

      eyeDropper.open()
        .then(result => {
          const hex = result.sRGBHex;
          // 即座に適用
          changeLayerLineColor(currentLayerForColorChange, hex);
          // iro.js の色も更新
          iroPicker.color.set(hex);
          notify(`画面から色を拾いました → ${hex}`);
        })
        .catch(err => {
          // キャンセル（Escキーなど）は静かに処理
          if (err.name !== 'AbortError' && err.name !== 'NotAllowedError') {
            console.warn('EyeDropper エラー:', err);
            notify('スポイトが失敗しました');
          } else {
            notify('スポイトをキャンセルしました');
          }
        });
    }
    // EyeDropper が使えないブラウザ用のフォールバック
    else {
      notify('このブラウザでは画面全体スポイトが使えません。キャンバス内をクリックして色を拾います（Escでキャンセル）');

      const area = document.getElementById('canvas-area');
      const previousCursor = area.style.cursor;
      area.style.cursor = 'crosshair';

      const onClick = (e) => {
        const pos = getPos(e); // 既存の getPos 関数を利用
        const ctx = layerCtxs[currentLayerForColorChange];
        const data = ctx.getImageData(Math.floor(pos.x), Math.floor(pos.y), 1, 1).data;
        const hex = '#' + 
          data[0].toString(16).padStart(2,'0') +
          data[1].toString(16).padStart(2,'0') +
          data[2].toString(16).padStart(2,'0');

        changeLayerLineColor(currentLayerForColorChange, hex);
        iroPicker.color.set(hex);
        notify(`キャンバスから ${hex} を拾いました`);

        cleanup();
      };

      const onEsc = (e) => {
        if (e.key === 'Escape') {
          notify('スポイトをキャンセルしました');
          cleanup();
        }
      };

      const cleanup = () => {
        area.removeEventListener('click', onClick);
        document.removeEventListener('keydown', onEsc);
        area.style.cursor = previousCursor;
      };

      area.addEventListener('click', onClick, { once: true });
      document.addEventListener('keydown', onEsc);
    }
  };

  // ポップアップを表示
  popup.classList.add('show');
}
// ミニカラーボタンを動的に作る関数
function generateMiniColorButtons() {
  const container = document.getElementById('mini-color-buttons');
  if (!container) return;

  // 以前のミニパレットと同じ色リスト（好みで増減OK）
  const colors = [
    '#000000', '#ffffff',
    '#e94560', '#0000ff', '#ffff00',
    '#87FF42', '#ff6b81', '#a855f7',
    '#4ecdc4', '#f9a825'
  ];

  colors.forEach(col => {
    const btn = document.createElement('button');
    btn.className = 'color-swatch';
    btn.style.background = col;
    btn.style.width = '32px';
    btn.style.height = '32px';
    btn.style.border = '2px solid #444';
    btn.style.borderRadius = '6px';
    btn.style.cursor = 'pointer';
    btn.title = col;

    // クリックで即適用（ピッカーの値も同期）
    btn.onclick = () => {
      if (currentLayerForColorChange >= 0) {
        changeLayerLineColor(currentLayerForColorChange, col);
        document.getElementById('layer-color-picker').value = col; // ピッカーも更新
        closeLayerPicker(); // すぐ閉じる（好みで外してもOK）
      }
    };

    container.appendChild(btn);
  });
}
// ピッカーを表示（🎨ボタン押下時）
function showLayerColorPalette(layerIndex, event) {
  event.stopPropagation();
  currentLayerForColorChange = layerIndex;

  createLayerPickerPopup();

  const pickerPopup = document.getElementById('layer-picker-popup');
  const colorInput = document.getElementById('layer-color-picker');

  // 現在のペン色を初期値に
  colorInput.value = S.penColor;

  // 右側固定表示
  pickerPopup.style.right = '30px';
  pickerPopup.style.top  = '100px';
  pickerPopup.classList.add('show');

  // 外クリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', closeLayerPickerOnOutside, { once: true });
  }, 0);
}

// 外クリックで閉じる
function closeLayerPickerOnOutside(e) {
  const popup = document.getElementById('layer-picker-popup');
  if (popup && !popup.contains(e.target)) {
    closeLayerPicker();
  }
}

function closeLayerPicker() {
  const popup = document.getElementById('layer-picker-popup');
  if (popup) popup.classList.remove('show');
  currentLayerForColorChange = -1;
}

// ★★★ ここが本命：レイヤー全体の線画色一括変更 ★★★
function changeLayerLineColor(layerIndex, newColor) {
  if (layerIndex < 0 || layerIndex >= LAYER_DEFS.length) return;

  pushUndo();  // 元に戻せるように

  let changedCount = 0;

  // そのレイヤーの全フレームを走査
  for (let f = 0; f < CF()[layerIndex].frames.length; f++) {
    const fr = CF()[layerIndex].frames[f];
    if (!fr || !fr.strokes || fr.strokes.length === 0) continue;

    let frameChanged = false;

    for (const s of fr.strokes) {
      // 線画（bezier/line/ellipse/rect）の色だけ変更
      if (s.type === 'bezier' || s.type === 'line' || 
          s.type === 'ellipse' || s.type === 'rect') {
        if (s.color !== newColor) {
          s.color = newColor;
          frameChanged = true;
        }
      }
    }

    if (frameChanged) changedCount++;
  }

  if (changedCount > 0) {
    renderAll();
    updateTimeline();
    notify(`レイヤー${layerIndex + 1} の線画色を ${newColor} に変更しました（${changedCount}フレーム）`);
  } else {
    notify('変更対象の線画が見つかりませんでした');
  }
}

</script>

<!-- レイヤーごとのカラーピッカー（隠し） -->
<input type="color" id="layer-color-picker" style="display:none;" value="#000000">

<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.5.2/dist/iro.min.js"></script>
</body>
</html>
